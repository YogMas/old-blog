{
    "version": "https://jsonfeed.org/version/1",
    "title": "S1m • All posts by \"javascript\" tag",
    "description": "博客记录个人学习笔记,处于不断完善中",
    "home_page_url": "https://github.com/YogMas/YogMas.github.io",
    "items": [
        {
            "id": "https://github.com/YogMas/YogMas.github.io/2021/11/06/javascript-ji-chu-ban/",
            "url": "https://github.com/YogMas/YogMas.github.io/2021/11/06/javascript-ji-chu-ban/",
            "title": "Javascript基础(未完待续)",
            "date_published": "2021-11-05T16:00:00.000Z",
            "content_html": "<h1 id=\"javascript\"><a class=\"markdownIt-Anchor\" href=\"#javascript\">#</a> javascript</h1>\n<h2 id=\"article-by-yogmas\"><a class=\"markdownIt-Anchor\" href=\"#article-by-yogmas\">#</a> Article By Yogmas</h2>\n<h3 id=\"js的组成\"><a class=\"markdownIt-Anchor\" href=\"#js的组成\">#</a> js 的组成</h3>\n<p>1.ECNscript:JS 语法<br>\n 2.DOM: 页面文档模型<br>\n 3.BOM: 浏览器对象模型</p>\n<h4 id=\"js初体验\"><a class=\"markdownIt-Anchor\" href=\"#js初体验\">#</a> js 初体验</h4>\n<p>1. 行内式 js: 直接写到元素的内部<br>\n<a href=\"https://imgtu.com/i/IGFyQJ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGFyQJ.png\" alt=\"IGFyQJ.png\"></a><br>\n2. 内嵌式的 js:</p>\n<blockquote>\n<pre><code>&lt;head&gt;&lt;script&gt; &lt;/script&gt;&lt;/head&gt;\n</code></pre>\n</blockquote>\n<p>3. 外部式 js: 创建 XXX.js 文件在通过标签引出到 html 文件中<br>\n<a href=\"https://imgtu.com/i/IGF2e1\"><img src=\"https://z3.ax1x.com/2021/11/08/IGF2e1.png\" alt=\"IGF2e1.png\"></a></p>\n<h4 id=\"js注释\"><a class=\"markdownIt-Anchor\" href=\"#js注释\">#</a> js 注释</h4>\n<blockquote>\n<pre><code>1.单行注释    //    ctrl + /\n2.多行注释     /*    */    shift + alt + a\n</code></pre>\n</blockquote>\n<h4 id=\"js输入输出语句\"><a class=\"markdownIt-Anchor\" href=\"#js输入输出语句\">#</a> js 输入输出语句</h4>\n<p><a href=\"https://imgtu.com/i/IGFWo6\"><img src=\"https://z3.ax1x.com/2021/11/08/IGFWo6.png\" alt=\"IGFWo6.png\"></a></p>\n<blockquote>\n<pre><code>prompt('') 输入框 \nalert('')警示框  展示给用户的\nconsole 控制台打印的信息 给程序员看的\n</code></pre>\n</blockquote>\n<h3 id=\"变量概述\"><a class=\"markdownIt-Anchor\" href=\"#变量概述\">#</a> 变量概述</h3>\n<h4 id=\"什么是变量\"><a class=\"markdownIt-Anchor\" href=\"#什么是变量\">#</a> 什么是变量</h4>\n<p>变量是用来存放数据的容器，简而言之就是一个装东西的盒子<br>\n变量是内存中申请的一部分用来存放数据的空间</p>\n<h3 id=\"变量的使用\"><a class=\"markdownIt-Anchor\" href=\"#变量的使用\">#</a> 变量的使用</h3>\n<h4 id=\"声明变量\"><a class=\"markdownIt-Anchor\" href=\"#声明变量\">#</a> 声明变量</h4>\n<blockquote>\n<p>var age;</p>\n</blockquote>\n<p>var 是一个 js 关键字用来声明变量<br>\n age 是程序员取的名字</p>\n<h4 id=\"赋值\"><a class=\"markdownIt-Anchor\" href=\"#赋值\">#</a> 赋值</h4>\n<p>赋值就是把值存入变量中</p>\n<blockquote>\n<p>age=10</p>\n</blockquote>\n<p>这里的 = 是赋值的意思 在变量中存储一个数据</p>\n<h4 id=\"变量的初始化\"><a class=\"markdownIt-Anchor\" href=\"#变量的初始化\">#</a> 变量的初始化</h4>\n<blockquote>\n<p>var age=18;</p>\n</blockquote>\n<p>在声明变量的同时赋值给 18  使程序变得更加简便</p>\n<blockquote>\n<pre><code>var myname = prompt('请输入你的名字')\n</code></pre>\n</blockquote>\n<p>这样在弹出的对话框里面输入的名字 可以储存到变量 myname 中去</p>\n<h4 id=\"变量语法扩展\"><a class=\"markdownIt-Anchor\" href=\"#变量语法扩展\">#</a> 变量语法扩展</h4>\n<h5 id=\"更新变量\"><a class=\"markdownIt-Anchor\" href=\"#更新变量\">#</a> 更新变量</h5>\n<blockquote>\n<pre><code> var myname = 'pink';\n console.log(myname);\n  myname = '迪丽热巴';\n  console.log(myname);\n</code></pre>\n</blockquote>\n<p>这样从上到下 第一次输出的 pink 第二次输出的是迪丽热巴  变量在不断更新</p>\n<h5 id=\"声明多个变量\"><a class=\"markdownIt-Anchor\" href=\"#声明多个变量\">#</a> 声明多个变量</h5>\n<blockquote>\n<pre><code>eg:var age=18,address='火影村'\n</code></pre>\n</blockquote>\n<p>这里声明了 age 和 address 多个变量，变量与变量之间通过英文的逗号隔开</p>\n<h5 id=\"声明变量的特殊情况\"><a class=\"markdownIt-Anchor\" href=\"#声明变量的特殊情况\">#</a> 声明变量的特殊情况</h5>\n<p>1. 只声明不赋值 这时候输出的结果是 undefined (未定义的)<br>\n 2. 不声明不赋值 直接使用 浏览器会进行报错<br>\n 3. 不声明直接赋值使用 在 js 之中只可以使用的</p>\n<p>注意:js 是从上到下处理的，如果中间有错误的代码，那么错误代码下面的代码将不再被 js 处理<br>\n<a href=\"https://imgtu.com/i/IG0QRf\"><img src=\"https://z3.ax1x.com/2021/11/08/IG0QRf.png\" alt=\"IG0QRf.png\"></a></p>\n<h5 id=\"变量命名规范\"><a class=\"markdownIt-Anchor\" href=\"#变量命名规范\">#</a> 变量命名规范</h5>\n<p><a href=\"https://imgtu.com/i/IGieEV\"><img src=\"https://z3.ax1x.com/2021/11/08/IGieEV.png\" alt=\"IGieEV.png\"></a><br>\n 尽量不要直接使用 name 作为变量名，name 在大部分浏览器中有变量含义</p>\n<h4 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\">#</a> 小结</h4>\n<p>自我问答环节<br>\n<a href=\"https://imgtu.com/i/IGin4U\"><img src=\"https://z3.ax1x.com/2021/11/08/IGin4U.png\" alt=\"IGin4U.png\"></a><br>\n<a href=\"https://imgtu.com/i/IGiM34\"><img src=\"https://z3.ax1x.com/2021/11/08/IGiM34.png\" alt=\"IGiM34.png\"></a></p>\n<h3 id=\"数据类型\"><a class=\"markdownIt-Anchor\" href=\"#数据类型\">#</a> 数据类型</h3>\n<h4 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h4>\n<p>不同的数据占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型.</p>\n<h4 id=\"变量的数据类型\"><a class=\"markdownIt-Anchor\" href=\"#变量的数据类型\">#</a> 变量的数据类型</h4>\n<p>js 是一种弱类型或者说动态语言，这意味着不用提前声明变量的类型，在程序运行的过程中，类型会自动确定.</p>\n<p>js 的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的.</p>\n<p>js 是动态语言，变量的数据类型是可以变化的</p>\n<blockquote>\n<p>var x = 10;x 是数字型<br>\n var x = ‘yogmas’; x 是字符串型</p>\n</blockquote>\n<h5 id=\"简单数据类型\"><a class=\"markdownIt-Anchor\" href=\"#简单数据类型\">#</a> 简单数据类型</h5>\n<p><a href=\"https://imgtu.com/i/IGFTQH\"><img src=\"https://z3.ax1x.com/2021/11/08/IGFTQH.png\" alt=\"IGFTQH.png\"></a></p>\n<h6 id=\"数字型\"><a class=\"markdownIt-Anchor\" href=\"#数字型\">#</a> 数字型</h6>\n<p>1. 在我们程序里面数字前面加 0 表示 8 进制</p>\n<blockquote>\n<pre><code>eg:var num = 010 转化为10进制就是8\n</code></pre>\n</blockquote>\n<p>2. 十六进制 0~9 a~f<br>\n 在数字前面加 0x 表示 16 进制</p>\n<blockquote>\n<pre><code>eg:var num = 0xa 转外为10进制就是10\n</code></pre>\n</blockquote>\n<p>3. 数字型的最大值</p>\n<blockquote>\n<pre><code>console.log(Number.MAX_VALUE)  1.7976e+308\n</code></pre>\n</blockquote>\n<p>4. 数字型的最小值</p>\n<blockquote>\n<pre><code>console.log(Number.MIN_VALUE)  5e-324\n</code></pre>\n</blockquote>\n<p>数字型的三个特殊数值<br>\n alert (infinity) 无穷大<br>\n alert (-infinity) 无穷小<br>\n这两个数都可以通过将前面的最大数或者最小数通过加减乘除扩大或缩小得到<br>\n alert (NAN) 非数值</p>\n<p>可以通过 isNAN 用来判断非数字 并且返回一个值， 如果是数值返回的是 false 如果不是数字 返回的是 true<br>\nconsole.log(isNaN(XX));<br>\n<a href=\"https://imgtu.com/i/IGFOTP\"><img src=\"https://z3.ax1x.com/2021/11/08/IGFOTP.png\" alt=\"IGFOTP.png\"></a></p>\n<h5 id=\"字符串型\"><a class=\"markdownIt-Anchor\" href=\"#字符串型\">#</a> 字符串型</h5>\n<p>字符串数据类型用单引号圈出 (字符串必须加引号，不然会提示错误)</p>\n<p>注意引号内不能内嵌引号，如果要引号内嵌，使用不同的引号 (<strong>引号判定是就近一致原则</strong>)</p>\n<blockquote>\n<pre><code>例如:var str = \"我是一个'高富帅'程序员\";\n</code></pre>\n</blockquote>\n<h6 id=\"字符串长度\"><a class=\"markdownIt-Anchor\" href=\"#字符串长度\">#</a> 字符串长度</h6>\n<p>检测获取字符串的长度 用 length</p>\n<blockquote>\n<pre><code>        var str = 'my name is andy ';\n        console.log(str.length)\n</code></pre>\n</blockquote>\n<h6 id=\"字符转义符\"><a class=\"markdownIt-Anchor\" href=\"#字符转义符\">#</a> 字符转义符</h6>\n<p><a href=\"https://imgtu.com/i/IGkmpF\"><img src=\"https://z3.ax1x.com/2021/11/08/IGkmpF.png\" alt=\"IGkmpF.png\"></a><br>\n 都是以 \\ 开头 ，但是这些转义字符要写到引号里面</p>\n<h6 id=\"字符串的拼接\"><a class=\"markdownIt-Anchor\" href=\"#字符串的拼接\">#</a> 字符串的拼接</h6>\n<blockquote>\n<pre><code>console.log ('' + '' + '')字符串之间通过加号连接\neg:console.log ('沙漠'+'骆驼 ') = '沙漠骆驼'\nconsole.log ('12' + 12) 最后为1212  这是字符串的相加   \nconsole.log (12 + 12) 最后为24   这是数字型的相加\n</code></pre>\n</blockquote>\n<p>只要有一个是字符串 其他全部都会以字符串相连<br>\n<strong>数字相加，字符相连</strong></p>\n<h6 id=\"字符串拼接加强\"><a class=\"markdownIt-Anchor\" href=\"#字符串拼接加强\">#</a> 字符串拼接加强</h6>\n<p>通过改变变量中的值 来改变显示中的值</p>\n<blockquote>\n<pre><code>eg:var age = 18;\n   console.log('pink老师'+age+'岁')\n</code></pre>\n</blockquote>\n<p>需要注意的时，<strong>变量不要写到字符串里面，是通过和字符串相连的方式实现的</strong></p>\n<blockquote>\n<pre><code>  console.log ('pink老师age岁')\n  console.log ('pink老师'+'age'+'岁')\n  console.log ('pink老师'+'age岁')\n</code></pre>\n</blockquote>\n<p>如上这些等等做法，都是不能实现的.<br>\n<a href=\"https://imgtu.com/i/IGku6J\"><img src=\"https://z3.ax1x.com/2021/11/08/IGku6J.png\" alt=\"IGku6J.png\"></a><br>\n 交互编程：</p>\n<p>用户输入 → 处理 → 输出</p>\n<blockquote>\n<pre><code>eg         var age = prompt('请输入您的年龄');\n           var str = '你今年已经' + age + '岁了';\n           alert(str);\n</code></pre>\n</blockquote>\n<h5 id=\"布尔型boolean\"><a class=\"markdownIt-Anchor\" href=\"#布尔型boolean\">#</a> 布尔型 Boolean</h5>\n<p>布尔型中有两个值 true 和 false</p>\n<blockquote>\n<pre><code>eg         var flag = true; 布尔型\n           var flag1 = false; 布尔型\n</code></pre>\n</blockquote>\n<p>需要注意的是参与加法运算时布尔型 true 就是 1，false 就是 0.</p>\n<h5 id=\"undefined-和null\"><a class=\"markdownIt-Anchor\" href=\"#undefined-和null\">#</a> Undefined 和 Null</h5>\n<p>如果一个变量声明未赋值 就是 undefined 未定义数据类型</p>\n<blockquote>\n<pre><code>   eg: var str;\n       console.log(var);\n</code></pre>\n</blockquote>\n<p>未定义和字符串相加，最终的结果是 undefined+ 字符串的内容</p>\n<p>undefined 和数字相加 最后得到的结果是 NaN: not a number</p>\n<p>null : 空值</p>\n<blockquote>\n<pre><code>var space = null\nconsole.log(space + 'yogmas')  输出的结果是 spaceyogmas\nconsole.log(space + 1) 输出的结果是1  (和undefined区别)\n</code></pre>\n</blockquote>\n<h4 id=\"获取变量数据类型\"><a class=\"markdownIt-Anchor\" href=\"#获取变量数据类型\">#</a> 获取变量数据类型</h4>\n<h5 id=\"使用typeof来检测\"><a class=\"markdownIt-Anchor\" href=\"#使用typeof来检测\">#</a> 使用 typeof 来检测</h5>\n<blockquote>\n<pre><code>   eg:   var num = 10;\n         console.log(typeof num);\n</code></pre>\n</blockquote>\n<p>比较特殊的是 在这里对 null 进行数据类型检测 输出来的是 object (对象)</p>\n<p>经过检测发现 我们 prompt 取过来的值是字符型的</p>\n<h5 id=\"观察控制台中的数据颜色\"><a class=\"markdownIt-Anchor\" href=\"#观察控制台中的数据颜色\">#</a> 观察控制台中的数据颜色</h5>\n<p>数字型 浅蓝色<br>\n字符型 黑色<br>\n布尔型 深蓝色<br>\n undefined 和 null 灰色</p>\n<h4 id=\"字面量\"><a class=\"markdownIt-Anchor\" href=\"#字面量\">#</a> 字面量</h4>\n<p>字面量是在源代码中一个固定值得表示法，通俗来说，就是字面量表示如何表达这个值<br>\n<a href=\"https://imgtu.com/i/IGkQmR\"><img src=\"https://z3.ax1x.com/2021/11/08/IGkQmR.png\" alt=\"IGkQmR.png\"></a></p>\n<h4 id=\"数据类型转换\"><a class=\"markdownIt-Anchor\" href=\"#数据类型转换\">#</a> 数据类型转换</h4>\n<p>通常会实现 3 中方式的转换<br>\n 1. 转换为字符串类型<br>\n 2. 转换为数字型<br>\n 3. 转换为布尔型</p>\n<h5 id=\"转换成字符串型\"><a class=\"markdownIt-Anchor\" href=\"#转换成字符串型\">#</a> 转换成字符串型</h5>\n<p><a href=\"https://imgtu.com/i/IGkGtK\"><img src=\"https://z3.ax1x.com/2021/11/08/IGkGtK.png\" alt=\"IGkGtK.png\"></a></p>\n<blockquote>\n<pre><code>var num = 18;\nconsole.log(num.toString())\nconsole.log(String(num))\nconsole.log(num + '')\n</code></pre>\n</blockquote>\n<p>注意:toString () 和 String () 的使用方法不同<br>\n三种方法中 其中拼接转换字符串最为实用</p>\n<h5 id=\"转换为数字型重点\"><a class=\"markdownIt-Anchor\" href=\"#转换为数字型重点\">#</a> 转换为数字型 (重点)</h5>\n<p><a href=\"https://imgtu.com/i/IGkN1e\"><img src=\"https://z3.ax1x.com/2021/11/08/IGkN1e.png\" alt=\"IGkN1e.png\"></a><br>\n 其中前两个较为实用<br>\n 1.parseInt (变量) 可以把字符型的转换为数字型 但是得到的是整数 并且约分不会四舍五入，会直接去掉小数点后面的数字 如果数字后面有单位，也会去掉单位，如果以字母开头那么输出的为 NaN<br>\n2.paseFloat (变量) 可以把字符型的转化为数字型，得到的是浮点数也就是小数，但同样也会把后面的单位去掉<br>\n 3.Number (变量)<br>\n 4. 利用了算数运算 - * / 隐式转换<br>\n<a href=\"https://imgtu.com/i/IGk2cQ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGk2cQ.png\" alt=\"IGk2cQ.png\"></a></p>\n<blockquote>\n<pre><code>   console.log(parseInt('123'));\n   console.log(parseFloat('123'));\n   console.log(Number('123'));\n   console.log('12' - 0);\n   console.log('123' - '123');\n   console.log('123' * 1);\n</code></pre>\n</blockquote>\n<h5 id=\"转化为布尔型\"><a class=\"markdownIt-Anchor\" href=\"#转化为布尔型\">#</a> 转化为布尔型</h5>\n<p>代表<strong>空，否定</strong>的值会被转化为 false，如’’,0,NaN,null,undefined. 其他的值都会被转化成 true<br>\n<a href=\"https://imgtu.com/i/IGkjBR\"><img src=\"https://z3.ax1x.com/2021/11/08/IGkjBR.png\" alt=\"IGkjBR.png\"></a></p>\n<blockquote>\n<pre><code>eg: console.log(Boolean(''));      这是false\n</code></pre>\n</blockquote>\n<h4 id=\"解释型语言和编译型语言\"><a class=\"markdownIt-Anchor\" href=\"#解释型语言和编译型语言\">#</a> 解释型语言和编译型语言</h4>\n<p>编译型语言：全部编译成功后再执行代码.(做好菜 再吃饭)<br>\n 解释型语言：解释一行代码后就执行一行代码.(吃火锅：边吃边涮)</p>\n<h4 id=\"标识符关键字保留字\"><a class=\"markdownIt-Anchor\" href=\"#标识符关键字保留字\">#</a> 标识符，关键字，保留字</h4>\n<p>标识符：开发人员为变量，属性，函数，参数取的名字<br>\n<strong>标识符不能是关键字和保留字</strong><br>\n关键字：是指 js 本身已经使用了子，不能充当变量名和方法名<br>\n<a href=\"https://imgtu.com/i/IGBhAs\"><img src=\"https://z3.ax1x.com/2021/11/08/IGBhAs.png\" alt=\"IGBhAs.png\"></a><br>\n 保留字：预留的关键字，未来可能会成为关键字<br>\n<a href=\"https://imgtu.com/i/IGBHjU\"><img src=\"https://z3.ax1x.com/2021/11/08/IGBHjU.png\" alt=\"IGBHjU.png\"></a></p>\n<h3 id=\"运算符\"><a class=\"markdownIt-Anchor\" href=\"#运算符\">#</a> 运算符</h3>\n<h4 id=\"算数运算符\"><a class=\"markdownIt-Anchor\" href=\"#算数运算符\">#</a> 算数运算符</h4>\n<p><a href=\"https://imgtu.com/i/IGAQgg\"><img src=\"https://z3.ax1x.com/2021/11/08/IGAQgg.png\" alt=\"IGAQgg.png\"></a><br>\n 需要注意的是浮点数在算数运算里面会有问题 (会有一定的误差)</p>\n<blockquote>\n<pre><code>eg:console.log(0.07*100); 最终的结果是7.000000000000001\n</code></pre>\n</blockquote>\n<p><a href=\"https://imgtu.com/i/IGAaCT\"><img src=\"https://z3.ax1x.com/2021/11/08/IGAaCT.png\" alt=\"IGAaCT.png\"></a><br>\n 我们不能拿着浮点数来进行相比较是否相等</p>\n<h5 id=\"表达式返回值\"><a class=\"markdownIt-Anchor\" href=\"#表达式返回值\">#</a> 表达式，返回值</h5>\n<p>由数字，运算符，变量等组成的式子</p>\n<p>在程序中的计算是把右边表达式计算完毕把返回值给左边</p>\n<p>式子通过计算得到的结果 称为返回值</p>\n<h4 id=\"自增和自减运算符\"><a class=\"markdownIt-Anchor\" href=\"#自增和自减运算符\">#</a> 自增和自减运算符</h4>\n<p>反复用给数字变量添加或者减去 1，可以用 ++ 或者–来实现<br>\n在 js 中，自增自减运算符既可以放在变量前面又可以放在变量后面，称为前置或者后置.<br>\n 需要注意的是 这个运算符必须和变量配合才能使用<br>\n前置和后置有区别的是，前置表示先自增或自减再返回，后置表示先返回再自增或自减<br>\n<a href=\"https://imgtu.com/i/IGYJ4U\"><img src=\"https://z3.ax1x.com/2021/11/08/IGYJ4U.png\" alt=\"IGYJ4U.png\"></a></p>\n<h4 id=\"比较运算符关系运算符\"><a class=\"markdownIt-Anchor\" href=\"#比较运算符关系运算符\">#</a> 比较运算符 &amp; 关系运算符</h4>\n<p><a href=\"https://imgtu.com/i/IGYwuR\"><img src=\"https://z3.ax1x.com/2021/11/08/IGYwuR.png\" alt=\"IGYwuR.png\"></a><br>\n<a href=\"https://imgtu.com/i/IGYy4O\"><img src=\"https://z3.ax1x.com/2021/11/08/IGYy4O.png\" alt=\"IGYy4O.png\"></a></p>\n<h4 id=\"逻辑运算符\"><a class=\"markdownIt-Anchor\" href=\"#逻辑运算符\">#</a> 逻辑运算符</h4>\n<p><a href=\"https://imgtu.com/i/IGYhDI\"><img src=\"https://z3.ax1x.com/2021/11/08/IGYhDI.png\" alt=\"IGYhDI.png\"></a></p>\n<h5 id=\"短路运算逻辑中断\"><a class=\"markdownIt-Anchor\" href=\"#短路运算逻辑中断\">#</a> 短路运算 (逻辑中断)</h5>\n<p>原理：左边表达式的值可以确定结果时，就不再继续运算右边的值</p>\n<p>逻辑与：如果表达式 1 结果为真，则返回表达式 2. 如果表达式 1 结果为假，则返回表达式 1<br>\n<a href=\"https://imgtu.com/i/IGYIVP\"><img src=\"https://z3.ax1x.com/2021/11/08/IGYIVP.png\" alt=\"IGYIVP.png\"></a><br>\n<a href=\"https://imgtu.com/i/IGYoUf\"><img src=\"https://z3.ax1x.com/2021/11/08/IGYoUf.png\" alt=\"IGYoUf.png\"></a><br>\n 逻辑或：如果表达式 1 结果为真，则返回表达式 1. 如果表达式 1 结果为假，则返回表达式 2.<br>\n<a href=\"https://imgtu.com/i/IGYT58\"><img src=\"https://z3.ax1x.com/2021/11/08/IGYT58.png\" alt=\"IGYT58.png\"></a></p>\n<h5 id=\"赋值运算符\"><a class=\"markdownIt-Anchor\" href=\"#赋值运算符\">#</a> 赋值运算符</h5>\n<p>把右边的数据赋给左边的变量<br>\n<a href=\"https://imgtu.com/i/IGYLvj\"><img src=\"https://z3.ax1x.com/2021/11/08/IGYLvj.png\" alt=\"IGYLvj.png\"></a></p>\n<h5 id=\"运算符优先级\"><a class=\"markdownIt-Anchor\" href=\"#运算符优先级\">#</a> 运算符优先级</h5>\n<p><a href=\"https://imgtu.com/i/IGtSaV\"><img src=\"https://z3.ax1x.com/2021/11/08/IGtSaV.png\" alt=\"IGtSaV.png\"></a><br>\n 注意逻辑与的权重大于逻辑或的权重</p>\n<h3 id=\"流程控制-分支\"><a class=\"markdownIt-Anchor\" href=\"#流程控制-分支\">#</a> 流程控制 - 分支</h3>\n<h4 id=\"流程控制\"><a class=\"markdownIt-Anchor\" href=\"#流程控制\">#</a> 流程控制</h4>\n<p>控制代码按照什么结构顺序来执行</p>\n<p>流程控制有三种结构，分别是顺序结构，分支结构和循环结构<br>\n<a href=\"https://imgtu.com/i/IGti24\"><img src=\"https://z3.ax1x.com/2021/11/08/IGti24.png\" alt=\"IGti24.png\"></a></p>\n<h5 id=\"顺序流程控制\"><a class=\"markdownIt-Anchor\" href=\"#顺序流程控制\">#</a> 顺序流程控制</h5>\n<p>按照写的代码的顺序从上到下执行，我们现在的代码大多数都是按照顺序流程控制来写的</p>\n<h5 id=\"分支流程控制\"><a class=\"markdownIt-Anchor\" href=\"#分支流程控制\">#</a> 分支流程控制</h5>\n<p>从上到下执行代码的过程中，根据不同的条件，执行不同的路径代码，从而得到不同的结果</p>\n<h4 id=\"if分支语句\"><a class=\"markdownIt-Anchor\" href=\"#if分支语句\">#</a> if 分支语句</h4>\n<blockquote>\n<pre><code>if (条件表达式) {执行语句}\n</code></pre>\n</blockquote>\n<p>如果条件表达式结果为真就执行大括号里面的执行语句<br>\n如果条件表达式结果为假就执行 if 语句后面的代码<br>\n<a href=\"https://imgtu.com/i/IGBOHJ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGBOHJ.png\" alt=\"IGBOHJ.png\"></a><br>\n<a href=\"https://imgtu.com/i/IGBx41\"><img src=\"https://z3.ax1x.com/2021/11/08/IGBx41.png\" alt=\"IGBx41.png\"></a></p>\n<h5 id=\"if-else-双分支语句\"><a class=\"markdownIt-Anchor\" href=\"#if-else-双分支语句\">#</a> if else 双分支语句</h5>\n<p><a href=\"https://imgtu.com/i/IGDp36\"><img src=\"https://z3.ax1x.com/2021/11/08/IGDp36.png\" alt=\"IGDp36.png\"></a><br>\n 如果表达式结果为真，那么执行语句 1 否则执行语句 2<br>\n 语句 1 和语句 2 只能二选一执行<br>\n else 后面直接加大括号而不是小括号<br>\n<a href=\"https://imgtu.com/i/IGDVUA\"><img src=\"https://z3.ax1x.com/2021/11/08/IGDVUA.png\" alt=\"IGDVUA.png\"></a></p>\n<h5 id=\"if-else-多分支语句\"><a class=\"markdownIt-Anchor\" href=\"#if-else-多分支语句\">#</a> if else 多分支语句</h5>\n<p>利用多个条件来选择不同的语句执行，得到不同的结果，是多选 1 的过程</p>\n<p>语法规范:<br>\nif (条件表达式 1) {</p>\n<p>} else if (条件表达式 2) {</p>\n<p>} else if …{</p>\n<p>} else {<br>\n最后的语句<br>\n}<br>\n 如果条件表达式 1 满足就执行语句 1，执行完毕后退出整个 if 分支语句<br>\n如果条件 1 不满足就判断表达式 2 以此类推<br>\n如果全都不成立，则执行最后的 else 里面的语句<br>\n注意<br>\n 1. 多分支语句还是多选 1 最后只有 1 个语句能执行<br>\n 2.else if 里面的条件理论上是可以任意多个的<br>\n 3.else if 中间有个空格<br>\n<a href=\"https://imgtu.com/i/IGD9gK\"><img src=\"https://z3.ax1x.com/2021/11/08/IGD9gK.png\" alt=\"IGD9gK.png\"></a></p>\n<h4 id=\"三元表达式\"><a class=\"markdownIt-Anchor\" href=\"#三元表达式\">#</a> 三元表达式</h4>\n<p>有三元运算符组成的式子我们称为三元表达式</p>\n<p>条件表达式 1? 表达式 1: 表达式 2</p>\n<p>如果条件表达式结果为真，则返回表达式 1 的值，如果条件表达式的结果为假，则返回表达式 2 的值</p>\n<h4 id=\"switch语句\"><a class=\"markdownIt-Anchor\" href=\"#switch语句\">#</a> switch 语句</h4>\n<p>也是多分支语句可以实现多选 1 的效果<br>\n<a href=\"https://imgtu.com/i/IGDn8P\"><img src=\"https://z3.ax1x.com/2021/11/08/IGDn8P.png\" alt=\"IGDn8P.png\"></a><br>\n 语法结构:<br>\nswitch (表达式) {<br>\ncase value1:<br>\n 执行语句 1;<br>\nbreak;<br>\ncase value2:<br>\n 执行语句 2;<br>\nbreak;<br>\n…………<br>\ndefault :<br>\n 执行最后的语句；<br>\n}<br>\n 利用表达式的值和 case 里面的选项匹配如果匹配上就执行相应的 case 里面的值，如果都没有匹配上就执行 default 里面的语句<br>\n<a href=\"https://imgtu.com/i/IGDKv8\"><img src=\"https://z3.ax1x.com/2021/11/08/IGDKv8.png\" alt=\"IGDKv8.png\"></a></p>\n<h4 id=\"switch语句和-if-else-if语句的区别\"><a class=\"markdownIt-Anchor\" href=\"#switch语句和-if-else-if语句的区别\">#</a> switch 语句和 if else if 语句的区别</h4>\n<p>一般情况下，他们两个语句可以相互替换<br>\n switch…case 语句 一般在 case 为比较固定值得情况下而 if…else 语句一般来判断范围<br>\n switch 判断时直接跳到判断语句上而 if 语句从上往下一次判断，这样 switch 语句的效率更高一点，但是如果分支少的话 if else if 的效率会更高一点，分支多的时候 switch 语句的效率更高<br>\n<a href=\"https://imgtu.com/i/IGDQKS\"><img src=\"https://z3.ax1x.com/2021/11/08/IGDQKS.png\" alt=\"IGDQKS.png\"></a></p>\n<h3 id=\"流程控制-循环\"><a class=\"markdownIt-Anchor\" href=\"#流程控制-循环\">#</a> 流程控制 - 循环</h3>\n<p>可以反复不断地循环执行某些代码</p>\n<h4 id=\"for循环\"><a class=\"markdownIt-Anchor\" href=\"#for循环\">#</a> for 循环</h4>\n<p>for 循环重复执行某些代码，通常和计数有关<br>\n被重复的语句称为循环体，是否重复执行取决于循环的终止条件，由循环体及循环的终止条件<br>\n初始化变量 就是用 var 声明的一个普通变量，通常用于作为计数器使用<br>\n条件表达式 就是用来决定每一次循环是否继续执行 就是终止的条件<br>\n操作表达式 是每次循环最后执行的代码，经常用来对我们的计数器进行更新 (递增或者递减)</p>\n<h5 id=\"断点调试\"><a class=\"markdownIt-Anchor\" href=\"#断点调试\">#</a> 断点调试</h5>\n<p>自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看着各个变量当前的值，出错的话，调试到出错的代码行及硻错误，停下.</p>\n<p>在浏览器调试中的 source 中可以进行断点调试<br>\n<a href=\"https://imgtu.com/i/IGtai8\"><img src=\"https://z3.ax1x.com/2021/11/08/IGtai8.png\" alt=\"IGtai8.png\"></a></p>\n<h5 id=\"for循环重复相同的代码\"><a class=\"markdownIt-Anchor\" href=\"#for循环重复相同的代码\">#</a> for 循环重复相同的代码</h5>\n<blockquote>\n<pre><code>   var num = prompt('请输入重复的次数');\n   for (i = 1; i &lt;= num; i++) {\n   console.log('你是大傻逼');\n   }\n</code></pre>\n</blockquote>\n<h5 id=\"for循环重复不同的代码\"><a class=\"markdownIt-Anchor\" href=\"#for循环重复不同的代码\">#</a> for 循环重复不同的代码</h5>\n<p>循环可以重复执行不同的代码，因为计数器变量 i 的存在 i 每次循环值都会变化</p>\n<blockquote>\n<pre><code>   for (var i = 1; i &lt;= 100; i++) {\n   console.log('这个人今年' + i + '岁了');\n   }\n</code></pre>\n</blockquote>\n<h5 id=\"for循环重复相同的操作\"><a class=\"markdownIt-Anchor\" href=\"#for循环重复相同的操作\">#</a> for 循环重复相同的操作</h5>\n<p>例如:</p>\n<blockquote>\n<pre><code>   var sum = 0, aver = 0;\n   for (var i = 1; i &lt;= 100; i++) {\n   sum += i\n   }\n   aver = sum / i\n   console.log(aver);\n</code></pre>\n</blockquote>\n<h5 id=\"双重for循环\"><a class=\"markdownIt-Anchor\" href=\"#双重for循环\">#</a> 双重 for 循环</h5>\n<p>也就是 for 循环嵌套，在一个循环语句中 再定义一个循环语句.</p>\n<blockquote>\n<pre><code>for (外层的初始化变量;外层的条件表达式;外层的操作表达式) {\n     for (初始化变量;条件表达式;操作表达式){\n     }\n     }\n</code></pre>\n</blockquote>\n<p>里层的循环可以看成是外层循环的语句</p>\n<h5 id=\"for循环小结\"><a class=\"markdownIt-Anchor\" href=\"#for循环小结\">#</a> for 循环小结</h5>\n<p><a href=\"https://imgtu.com/i/IGD1bQ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGD1bQ.png\" alt=\"IGD1bQ.png\"></a></p>\n<h4 id=\"while循环\"><a class=\"markdownIt-Anchor\" href=\"#while循环\">#</a> while 循环</h4>\n<p><a href=\"https://imgtu.com/i/IGD8Ej\"><img src=\"https://z3.ax1x.com/2021/11/08/IGD8Ej.png\" alt=\"IGD8Ej.png\"></a></p>\n<p>条件表达式结果为 true 则执行循环体 否则 退出循环</p>\n<p>while 循环中应该也有计数器初始化变量，也该有操作表达式完成计数器的更新防止死循环</p>\n<h4 id=\"do-while-循环\"><a class=\"markdownIt-Anchor\" href=\"#do-while-循环\">#</a> do while 循环</h4>\n<p>语法结构</p>\n<blockquote>\n<p>do {循环体} while (条件表达式)</p>\n</blockquote>\n<p>执行思路不同的地方跟 while 在于 do whild 先执行一遍循环体再判断条件<br>\n do while 语句至少执行一次循环体</p>\n<p><a href=\"https://imgtu.com/i/IGDwKU\"><img src=\"https://z3.ax1x.com/2021/11/08/IGDwKU.png\" alt=\"IGDwKU.png\"></a></p>\n<h4 id=\"循环小结\"><a class=\"markdownIt-Anchor\" href=\"#循环小结\">#</a> 循环小结</h4>\n<p><a href=\"https://imgtu.com/i/IGtwRg\"><img src=\"https://z3.ax1x.com/2021/11/08/IGtwRg.png\" alt=\"IGtwRg.png\"></a></p>\n<h3 id=\"continue关键字\"><a class=\"markdownIt-Anchor\" href=\"#continue关键字\">#</a> continue 关键字</h3>\n<p>用于立即跳出本次循环，继续下一次循环.</p>\n<h3 id=\"break关键字\"><a class=\"markdownIt-Anchor\" href=\"#break关键字\">#</a> break 关键字</h3>\n<p>break 退出整个循环，使循环立马结束</p>\n<h3 id=\"命名规范\"><a class=\"markdownIt-Anchor\" href=\"#命名规范\">#</a> 命名规范</h3>\n<h4 id=\"标志符命名规范\"><a class=\"markdownIt-Anchor\" href=\"#标志符命名规范\">#</a> 标志符命名规范</h4>\n<p><a href=\"https://imgtu.com/i/IGtrss\"><img src=\"https://z3.ax1x.com/2021/11/08/IGtrss.png\" alt=\"IGtrss.png\"></a></p>\n<h4 id=\"操作符规范\"><a class=\"markdownIt-Anchor\" href=\"#操作符规范\">#</a> 操作符规范</h4>\n<p>操作符左右两侧各保留一个空格<br>\n单行注释在 // 后面敲个空格</p>\n<h4 id=\"循环作业\"><a class=\"markdownIt-Anchor\" href=\"#循环作业\">#</a> 循环作业</h4>\n<p><a href=\"https://imgtu.com/i/IGtgoV\"><img src=\"https://z3.ax1x.com/2021/11/08/IGtgoV.png\" alt=\"IGtgoV.png\"></a></p>\n<h3 id=\"javascript数组\"><a class=\"markdownIt-Anchor\" href=\"#javascript数组\">#</a> javascript 数组</h3>\n<h4 id=\"数组的概念\"><a class=\"markdownIt-Anchor\" href=\"#数组的概念\">#</a> 数组的概念</h4>\n<p>数组是一组数据的集合，其中每个数据都被称为元素，在数组中可以存放任何类型的元素，数组是可以将数据存储在单个变量下的优雅方式</p>\n<h4 id=\"创建数组\"><a class=\"markdownIt-Anchor\" href=\"#创建数组\">#</a> 创建数组</h4>\n<p>1.new 创建数组<br>\n 2. 利用数组关键字创造数组</p>\n<h5 id=\"利用new创建数组\"><a class=\"markdownIt-Anchor\" href=\"#利用new创建数组\">#</a> 利用 new 创建数组</h5>\n<p><a href=\"https://imgtu.com/i/IGrSaj\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrSaj.png\" alt=\"IGrSaj.png\"></a><br>\n 注意 Array 的 A 要大写</p>\n<h5 id=\"利用数组字面量创建数组\"><a class=\"markdownIt-Anchor\" href=\"#利用数组字面量创建数组\">#</a> 利用数组字面量创建数组</h5>\n<p>[] 是数组的的字面量</p>\n<blockquote>\n<p>var arr = [];<br>\n 这样便创建了一个空的数组<br>\n var arr = [1,1,2,3,‘pink’,true]</p>\n</blockquote>\n<p>在数组内可以放任何的数据类型，但是每一个数据之间必须用逗号分隔.</p>\n<h4 id=\"获取数组元素\"><a class=\"markdownIt-Anchor\" href=\"#获取数组元素\">#</a> 获取数组元素</h4>\n<h5 id=\"数组的索引\"><a class=\"markdownIt-Anchor\" href=\"#数组的索引\">#</a> 数组的索引</h5>\n<p>索引又被称为下标：用来访问数组元素的序号 (数组下标从 0 开始)<br>\n<a href=\"https://imgtu.com/i/IGNAfS\"><img src=\"https://z3.ax1x.com/2021/11/08/IGNAfS.png\" alt=\"IGNAfS.png\"></a></p>\n<blockquote>\n<pre><code> 数组名[索引号]\n console.log(arr[1])\n</code></pre>\n</blockquote>\n<p><strong>索引号从 0 开始</strong><br>\n如果没有该数组元素 就会输出 undefined</p>\n<h4 id=\"遍历数组\"><a class=\"markdownIt-Anchor\" href=\"#遍历数组\">#</a> 遍历数组</h4>\n<p>遍历：就是把数组中的每个元素从头到尾访问一次</p>\n<blockquote>\n<pre><code>eg:var arr = [1, 2, 3, 4, 5, 'pink'];\n   for (i = 0; i &lt; 6; i++) {\n   console.log(arr[i]);\n   }\n</code></pre>\n</blockquote>\n<p>输出的时候计数器当索引号来用</p>\n<h5 id=\"数组长度\"><a class=\"markdownIt-Anchor\" href=\"#数组长度\">#</a> 数组长度</h5>\n<p>数组名.length  可以访问数组中的数组元素的数量</p>\n<blockquote>\n<pre><code>console.log(arr.length);\n</code></pre>\n</blockquote>\n<p>同时 数组名.length 可以动态检测数组元素的个数</p>\n<h4 id=\"数组中新增元素\"><a class=\"markdownIt-Anchor\" href=\"#数组中新增元素\">#</a> 数组中新增元素</h4>\n<h5 id=\"通过修改length长度新增数组长度\"><a class=\"markdownIt-Anchor\" href=\"#通过修改length长度新增数组长度\">#</a> 通过修改 length 长度新增数组长度</h5>\n<blockquote>\n<pre><code>   var arr = ['pink', 'red', 'blue'];\n   arr.length = 5\n</code></pre>\n</blockquote>\n<p>如果扩容的数组元素中没有给值，其中的元素是 undefined</p>\n<h5 id=\"修改索引号-增加数组元素\"><a class=\"markdownIt-Anchor\" href=\"#修改索引号-增加数组元素\">#</a> 修改索引号 增加数组元素</h5>\n<blockquote>\n<pre><code>var arr = ['pink', 'red', 'blue'];\narr[3] = 'pink'\n</code></pre>\n</blockquote>\n<p>如果这个索引号原先已经被占用，就会替换原来的数组元素<br>\n<strong>不要直接给数组名赋值，否则会覆盖掉以前的数据，导致数据一个都没有了</strong></p>\n<h4 id=\"筛选数组的方法\"><a class=\"markdownIt-Anchor\" href=\"#筛选数组的方法\">#</a> 筛选数组的方法</h4>\n<h5 id=\"方法1\"><a class=\"markdownIt-Anchor\" href=\"#方法1\">#</a> 方法 1</h5>\n<blockquote>\n<pre><code>   var arr = [1, 2, 3, 4, 5, 6, 8, 11, 45, 13, 48, 46, 13];\n   var newArr = [];\n   var j = 0;\n   for (var i = 0; i &lt; arr.length; i++) {\n       if (arr[i] &gt; 10) {\n           newArr[j] = arr[i]\n           j++\n       }\n   }\n   console.log(newArr);\n</code></pre>\n</blockquote>\n<p>这里通过声明一个变量 j 来使新数组从 0 开始</p>\n<h5 id=\"方法2\"><a class=\"markdownIt-Anchor\" href=\"#方法2\">#</a> 方法 2</h5>\n<blockquote>\n<pre><code>   var arr = [1, 2, 3, 4, 5, 6, 8, 11, 45, 13, 48, 46, 13];\n   var newArr = [];\n   for (var i = 0; i &lt; arr.length; i++) {\n       if (arr[i] &gt; 10) {\n           newArr[newArr.length] = arr[i]\n       }\n   }\n   console.log(newArr);\n</code></pre>\n</blockquote>\n<p>将 j 替换成 newArr, 最开始当新数组里面没有元素时是 0，当有元素时 newArr.length 开始不断增多</p>\n<h4 id=\"翻转数组\"><a class=\"markdownIt-Anchor\" href=\"#翻转数组\">#</a> 翻转数组</h4>\n<blockquote>\n<pre><code>   var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n   var newArr = [];\n   for (i = arr.length - 1; i &gt;= 0; i--) {\n       newArr[newArr.length] = arr[i]\n   }\n   console.log(newArr);\n</code></pre>\n</blockquote>\n<p>这里需要注意的是：元素的索引号的最大值等于数组长度 - 1</p>\n<h4 id=\"冒泡排序\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序\">#</a> 冒泡排序</h4>\n<p>是一种算法，把一系列数组按照一定的顺序进行排列显示 (从小到大或者从大到小)<br>\n 算法：观察执行过程，从而找到其中的规律，并且找到代码</p>\n<blockquote>\n<pre><code>   var arr = [1, 5, 4, 3, 2];\n   for (var i = 0; i &lt; arr.length - 1; i++) { // 外层循环次数\n       for (var j = 0; j &lt; arr.length - i - 1; j++) { // 内层循环次数\n           if (arr[j] &gt; arr[j + 1]) {\n               var temp = arr[j]\n               arr[j] = arr[j + 1]\n               arr[j + 1] = temp\n           }\n       }\n   }\n</code></pre>\n</blockquote>\n<h3 id=\"javascript函数\"><a class=\"markdownIt-Anchor\" href=\"#javascript函数\">#</a> javascript 函数</h3>\n<h4 id=\"函数的概念\"><a class=\"markdownIt-Anchor\" href=\"#函数的概念\">#</a> 函数的概念</h4>\n<p>js 中经常会定义相同的代码，这些代码可能会大量使用<br>\n函数：就是封装了一段可被重复调用执行的代码块，通过调用代码块可以实现大量代码的重复使用.</p>\n<h4 id=\"函数的使用\"><a class=\"markdownIt-Anchor\" href=\"#函数的使用\">#</a> 函数的使用</h4>\n<p>步骤：1. 声明函数 2. 调用函数</p>\n<h5 id=\"声明函数\"><a class=\"markdownIt-Anchor\" href=\"#声明函数\">#</a> 声明函数</h5>\n<blockquote>\n<pre><code>function 函数名() {函数体}\n</code></pre>\n</blockquote>\n<p>注意事项：1.function 声明函数的关键字 全部小写 2. 函数是做某件事情，函数名一般是动词 3. 函数不调用自己不会执行</p>\n<h5 id=\"调用函数\"><a class=\"markdownIt-Anchor\" href=\"#调用函数\">#</a> 调用函数</h5>\n<blockquote>\n<pre><code>函数名();\n</code></pre>\n</blockquote>\n<p>调用函数时，千万不要忘了加小括号.</p>\n<h5 id=\"函数的参数\"><a class=\"markdownIt-Anchor\" href=\"#函数的参数\">#</a> 函数的参数</h5>\n<p>我们可以利用函数的参数实现函数重复不同的代码<br>\n参数: 1. 形参 2. 实参<br>\n<a href=\"https://imgtu.com/i/IGrNod\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrNod.png\" alt=\"IGrNod.png\"></a></p>\n<blockquote>\n<pre><code>function (形参1,形参2,....) {  在声明函数的小括号里面是形参\n }\n函数名(实参1,实参2...)     在函数调用的小括号里面是实参\n</code></pre>\n</blockquote>\n<p>形参类似于一个变量来接受实参的<br>\n函数的参数可以有也可以没有，个数不限<br>\n多个参数之间用逗号隔开</p>\n<h6 id=\"函数形参实参个数匹配\"><a class=\"markdownIt-Anchor\" href=\"#函数形参实参个数匹配\">#</a> 函数形参实参个数匹配</h6>\n<p>1. 如果实参的个数和形参的个数一直，则正常输出结果<br>\n 2. 如果实参的个数多于形参的个数，会取到形参的个数，实参中多的自动忽略<br>\n 3. 如果实参的个数小于形参的个数，num2 可以看做一个变量但是没有接收值，所以最终的结果就是 undefined<br>\n<a href=\"https://imgtu.com/i/IGN3fU\"><img src=\"https://z3.ax1x.com/2021/11/08/IGN3fU.png\" alt=\"IGN3fU.png\"></a></p>\n<h6 id=\"函数参数小结\"><a class=\"markdownIt-Anchor\" href=\"#函数参数小结\">#</a> 函数参数小结</h6>\n<p><a href=\"https://imgtu.com/i/IGrBSP\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrBSP.png\" alt=\"IGrBSP.png\"></a></p>\n<h5 id=\"函数的返回值\"><a class=\"markdownIt-Anchor\" href=\"#函数的返回值\">#</a> 函数的返回值</h5>\n<h6 id=\"return语句\"><a class=\"markdownIt-Anchor\" href=\"#return语句\">#</a> return 语句</h6>\n<p>函数只是实现某种功能，最终的结果需要返回给函数的调用者函数名 () 通过 return 实现<br>\n只要函数遇到 return 就把后面的结果返回给函数的调用者 函数名 ()=return 后面的结果</p>\n<blockquote>\n<pre><code> function 函数名() {\n       return 需要返回的结果;\n }\n 函数名();\n</code></pre>\n</blockquote>\n<p>代码验证</p>\n<blockquote>\n<pre><code>   function getSum(num1, num2) {\n       return num1 + num2;\n   }\n   console.log(getSum(1, 3));\n</code></pre>\n</blockquote>\n<p>这样输出的结果就是 4 (来自于 1+3)</p>\n<p>return 终止函数：函数遇到 return 就终止函数<br>\n return 的返回值:return 只能返回一个值，如果有多个值，return 只返回最后一个值<br>\n如果想要返回多个数值时，我们可以将数值放在一个数组里面，一个数组代表一个结果<br>\n函数如果 return 则返回的是 return 后面的值，如果函数没有 return 就返回 undefined<br>\nbreak,continue,return 的区别:<br>\n<a href=\"https://imgtu.com/i/IGrDQf\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrDQf.png\" alt=\"IGrDQf.png\"></a></p>\n<h4 id=\"函数的理解\"><a class=\"markdownIt-Anchor\" href=\"#函数的理解\">#</a> 函数的理解</h4>\n<p><a href=\"https://imgtu.com/i/IGNJl4\"><img src=\"https://z3.ax1x.com/2021/11/08/IGNJl4.png\" alt=\"IGNJl4.png\"></a></p>\n<h4 id=\"函数的作业\"><a class=\"markdownIt-Anchor\" href=\"#函数的作业\">#</a> 函数的作业</h4>\n<p><a href=\"https://imgtu.com/i/IGrWYn\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrWYn.png\" alt=\"IGrWYn.png\"></a></p>\n<h4 id=\"arguments的作用\"><a class=\"markdownIt-Anchor\" href=\"#arguments的作用\">#</a> arguments 的作用</h4>\n<p>当我们不确定有多少个参数传递时，可以用 argument 在获取，他实际上是当前函数的一个内置对象，arguements 存储了传递过来的所有实参</p>\n<p>arguments 实际上是伪数组.<br>\n 伪数组:<br>\n1. 具有数组的 length 属性.<br>\n2. 按照索引的方式进行存储.<br>\n3. 没有真正数组的一些方法:pop () 等</p>\n<h4 id=\"函数可以调用另外一个函数\"><a class=\"markdownIt-Anchor\" href=\"#函数可以调用另外一个函数\">#</a> 函数可以调用另外一个函数</h4>\n<h4 id=\"函数的两种声明方式\"><a class=\"markdownIt-Anchor\" href=\"#函数的两种声明方式\">#</a> 函数的两种声明方式</h4>\n<p>1. 利用函数关键字自定义函数</p>\n<blockquote>\n<pre><code>function fn() {\n}\nfn()\n</code></pre>\n</blockquote>\n<p>也被称为命名函数</p>\n<p>2. 函数表达式</p>\n<blockquote>\n<pre><code>var 变量名 = function() {}\n</code></pre>\n</blockquote>\n<p>又被叫做匿名函数<br>\n这是变量名不是函数名<br>\n函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存的是函数。</p>\n<h3 id=\"作用域\"><a class=\"markdownIt-Anchor\" href=\"#作用域\">#</a> 作用域</h3>\n<h4 id=\"作用域概述\"><a class=\"markdownIt-Anchor\" href=\"#作用域概述\">#</a> 作用域概述</h4>\n<p>1.js 的作用域就是代码名字在某个范围内起作用和效果 目的是为了提高程序的可靠性，重要的是减少命名冲突<br>\n 2.js 的作用域 (es6) 之前：全局作用域 和 局部作用域<br>\n 3. 全局作用域：整个 script 标签 或者是一个单独的 js 文件<br>\n 4. 局部作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起作用和效果 又叫做函数作用域</p>\n<h4 id=\"变量的作用域\"><a class=\"markdownIt-Anchor\" href=\"#变量的作用域\">#</a> 变量的作用域</h4>\n<p>根据作用域的不同我们变量分为全局变量和局部变量<br>\n 1. 全局变量：在全局作用域下的变量 在全局下都可以使用 (当然包括函数内部)<br>\n 2. 局部变量：在局部作用域下的变量 在函数内部的变量就是局部变量 只能在函数内部使用<br>\n 3. 特殊情况：如果在函数内部没有声明直接赋值的变量也称为全局变量，函数的形参也可以看成局部变量</p>\n<p>从执行效率来看全局变量和局部变量<br>\n 1. 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源<br>\n 2. 局部变量 当我们程序执行完毕就会销毁，比较节约内存支援<br>\n<strong>现阶段 js 没有块级作用域</strong></p>\n<h4 id=\"作用域链\"><a class=\"markdownIt-Anchor\" href=\"#作用域链\">#</a> 作用域链</h4>\n<p>内部函数访问外部函数的电量，采取的是链式查找的方式来决定取哪种值，这种结构我们称为作用域链<br>\n内部函数是可以访问外部函数的变量的</p>\n<h3 id=\"javascript预解析\"><a class=\"markdownIt-Anchor\" href=\"#javascript预解析\">#</a> javascript 预解析</h3>\n<p>1.js 解析器在运行 js 代码的时候分为两部分：先进行预解析，再进行代码执行<br>\n (2). 预解析:js 引擎会把 js 里面所有的 var 还有 function 提升到当前作用域的最前面<br>\n (3). 代码执行：按照代码书写的顺序从上往下执行.<br>\n2. 预解析分为变量预解析 (变量提升) 和函数预解析 (函数执行)<br>\n(1). 变量提升：就是把所有的变量声明提升到当前的作用域最前面 不提升赋值</p>\n<blockquote>\n<pre><code>console.log(num);\nvar num= 10;\n在预解析的时候执行顺序是这样的\nvar num;\nconsole.log(num);\nnum=10\n</code></pre>\n</blockquote>\n<p>(2). 函数声明：就是先把函数声明提升到当前作用域的最前面，不执行函数.</p>\n<h3 id=\"js对象\"><a class=\"markdownIt-Anchor\" href=\"#js对象\">#</a> js 对象</h3>\n<h4 id=\"对象概念\"><a class=\"markdownIt-Anchor\" href=\"#对象概念\">#</a> 对象概念</h4>\n<p>对象是一个具体的事物 (不是泛指)<br>\n 比如 明星不是对象 但刘德华是对象<br>\n<a href=\"https://imgtu.com/i/IGNspD\"><img src=\"https://z3.ax1x.com/2021/11/08/IGNspD.png\" alt=\"IGNspD.png\"></a></p>\n<h4 id=\"对象的使用方向\"><a class=\"markdownIt-Anchor\" href=\"#对象的使用方向\">#</a> 对象的使用方向</h4>\n<p>保存一个值可以使用变量，保存多个值可以使用数组，但如果保存一个人的完整信就需要用到对象了</p>\n<h4 id=\"创建对象的三种方式\"><a class=\"markdownIt-Anchor\" href=\"#创建对象的三种方式\">#</a> 创建对象的三种方式</h4>\n<p>1. 利用字面量创建对象<br>\n 2. 利用 new Object 创建对象<br>\n 3. 利用构造函数创建对象</p>\n<h4 id=\"对象字面量\"><a class=\"markdownIt-Anchor\" href=\"#对象字面量\">#</a> 对象字面量</h4>\n<p>{} 是对象的字面量<br>\n 1. 里面的属性或者方法我们采取键值对的形式 键 属性名：值 属性值<br>\n 2. 多个属性或者方法中间用逗号隔开，函数后面加；而不加逗号<br>\n 3. 方法冒号后面跟的是一个匿名函数</p>\n<h4 id=\"使用对象\"><a class=\"markdownIt-Anchor\" href=\"#使用对象\">#</a> 使用对象</h4>\n<p>调用对象的属性 我们采取 对象名。属性名</p>\n<blockquote>\n<p>console.log(obj.uname)</p>\n</blockquote>\n<p>其中这个。我们可以理解为的 比如说对象的属性<br>\n调用属性还有一种方法 对象名 [‘属性名’]</p>\n<blockquote>\n<p>console.log(abj[‘age’])</p>\n</blockquote>\n<p>需要注意的是 后面这种方法需要’' 而前面一种方法不需要<br>\n调用对象中的函数时，千万不要忘记添加小括号<br>\n<a href=\"https://imgtu.com/i/IGN66H\"><img src=\"https://z3.ax1x.com/2021/11/08/IGN66H.png\" alt=\"IGN66H.png\"></a></p>\n<h4 id=\"变量-属性-函数-方法的区别\"><a class=\"markdownIt-Anchor\" href=\"#变量-属性-函数-方法的区别\">#</a> 变量 属性 函数 方法的区别</h4>\n<p>相同点：都是用来存储数据的<br>\n不同点：1. 变量 单独声明并赋值 使用的时候直接写变量名 单独存在<br>\n 2. 属性 在对象里面的不需要声明的 使用的时候必须是 对象。属性</p>\n<p>函数和方法<br>\n相同点：都是实现某种功能 做某件事<br>\n不同点：函数时单独声明 并且调用的 是单独存在的<br>\n方法 在对象里面</p>\n<h4 id=\"利用new-object来创建对象\"><a class=\"markdownIt-Anchor\" href=\"#利用new-object来创建对象\">#</a> 利用 new Object 来创建对象</h4>\n<blockquote>\n<pre><code>var obj = new Object();   创建了一个空的对象\nobj.uname = '张三丰';\n</code></pre>\n</blockquote>\n<p>利用 等号 = 赋值的方法 添加对象的属性和方法<br>\n每个属性和方法之间用分号结束</p>\n<h4 id=\"利用构造函数创建对象\"><a class=\"markdownIt-Anchor\" href=\"#利用构造函数创建对象\">#</a> 利用构造函数创建对象</h4>\n<p>构造函数 就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面<br>\n语法格式:</p>\n<blockquote>\n<pre><code>function 构造函数名() {\n    this.属性 = 值;\n    this.方法 = function() {}\n }\n使用: new 构造函数名();\n</code></pre>\n</blockquote>\n<p>1. 构造函数名的首字母要大写<br>\n 2. 构造函数 不需要 return 就可以返回结果<br>\n 3. 我们调用构造函数必须使用 new<br>\n4. 属性和方法前面必须添加 this<br>\n<a href=\"https://imgtu.com/i/IGroOU\"><img src=\"https://z3.ax1x.com/2021/11/08/IGroOU.png\" alt=\"IGroOU.png\"></a></p>\n<h4 id=\"for-in遍历我们的对象\"><a class=\"markdownIt-Anchor\" href=\"#for-in遍历我们的对象\">#</a> for in 遍历我们的对象</h4>\n<blockquote>\n<pre><code>for (变量 in 对象) {\n  }\n</code></pre>\n</blockquote>\n<h3 id=\"javascript内置对象\"><a class=\"markdownIt-Anchor\" href=\"#javascript内置对象\">#</a> javascript 内置对象</h3>\n<p>1. 自定义对象<br>\n 2. 内置对象<br>\n 3. 浏览器对象 (js 特有)</p>\n<p>内置对象是 js 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或者是最基本的属性和方法<br>\n Math Date Array String</p>\n<h4 id=\"查阅文档\"><a class=\"markdownIt-Anchor\" href=\"#查阅文档\">#</a> 查阅文档</h4>\n<blockquote>\n<pre><code>https://developer.mozilla.org/zh-CN\n</code></pre>\n</blockquote>\n<p><a href=\"https://imgtu.com/i/IGNW7t\"><img src=\"https://z3.ax1x.com/2021/11/08/IGNW7t.png\" alt=\"IGNW7t.png\"></a></p>\n<h4 id=\"math对象\"><a class=\"markdownIt-Anchor\" href=\"#math对象\">#</a> Math 对象</h4>\n<p>不是一个构造函数，不用 new 来调用，直接使用即可<br>\n<a href=\"https://imgtu.com/i/IGr7mF\"><img src=\"https://z3.ax1x.com/2021/11/08/IGr7mF.png\" alt=\"IGr7mF.png\"></a></p>\n<p>Math.round 四舍五入中.5 是特殊数字 他往大了去  比如 - 1.5 的结果是 - 1</p>\n<h5 id=\"math随机数法\"><a class=\"markdownIt-Anchor\" href=\"#math随机数法\">#</a> Math 随机数法</h5>\n<blockquote>\n<pre><code>console.log(Math.random());\n</code></pre>\n</blockquote>\n<h4 id=\"date日期数法\"><a class=\"markdownIt-Anchor\" href=\"#date日期数法\">#</a> Date 日期数法</h4>\n<p>是一个构造函数 必须使用 new 来调用创建我们的日期对象</p>\n<blockquote>\n<pre><code>   var day = new Date();\n   console.log(day);\n</code></pre>\n</blockquote>\n<p>使用 date 如果没有参数 返回当前系统的当前时间<br>\n参数常用的写法 数字型 2019,10,01 或者是字符串型’2019-10-01’<br>\n<a href=\"https://imgtu.com/i/IGrbTJ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrbTJ.png\" alt=\"IGrbTJ.png\"></a></p>\n<h5 id=\"日期格式化date\"><a class=\"markdownIt-Anchor\" href=\"#日期格式化date\">#</a> 日期格式化 Date</h5>\n<p><a href=\"https://imgtu.com/i/IGNo9S\"><img src=\"https://z3.ax1x.com/2021/11/08/IGNo9S.png\" alt=\"IGNo9S.png\"></a><br>\n 返回的月份小一个月 记得月份 +1</p>\n<h5 id=\"获取日期的总的毫秒形式\"><a class=\"markdownIt-Anchor\" href=\"#获取日期的总的毫秒形式\">#</a> 获取日期的总的毫秒形式</h5>\n<p>Date 对象是基于 1970 年 1 月 1 日 (世界标准时间) 起的毫秒数</p>\n<blockquote>\n<pre><code>1.valueOf()    getTime()\n2.var date1= +new Date();\n3.H5新增 console(Date.now());\n</code></pre>\n</blockquote>\n<h4 id=\"数组对象array\"><a class=\"markdownIt-Anchor\" href=\"#数组对象array\">#</a> 数组对象 Array</h4>\n<p>1. 数组字面量创建<br>\n 2. 利用 new Array () 创建</p>\n<p>检测是非为数组<br>\n 1.instanceof Array<br>\n2.Array.isArray (参数)</p>\n<h5 id=\"添加删除数组元素的方法\"><a class=\"markdownIt-Anchor\" href=\"#添加删除数组元素的方法\">#</a> 添加删除数组元素的方法</h5>\n<p><a href=\"https://imgtu.com/i/IGN7cQ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGN7cQ.png\" alt=\"IGN7cQ.png\"></a><br>\n 添加:arr.push ();arr.unshift ();<br>\n 删除:arr.pop ();arr.shift;</p>\n<h5 id=\"数组排序\"><a class=\"markdownIt-Anchor\" href=\"#数组排序\">#</a> 数组排序</h5>\n<p><a href=\"https://imgtu.com/i/IGNqns\"><img src=\"https://z3.ax1x.com/2021/11/08/IGNqns.png\" alt=\"IGNqns.png\"></a></p>\n<blockquote>\n<pre><code>       arr1.sort(function (a, b) {\n       return a - b //升序的顺序排列\n       //return b - a 是降序的顺序排列\n        });\n</code></pre>\n</blockquote>\n<h5 id=\"数组索引方法\"><a class=\"markdownIt-Anchor\" href=\"#数组索引方法\">#</a> 数组索引方法</h5>\n<p><a href=\"https://imgtu.com/i/IGNO7q\"><img src=\"https://z3.ax1x.com/2021/11/08/IGNO7q.png\" alt=\"IGNO7q.png\"></a><br>\n 注意，如果有两个重复 只范湖第一个满足条件的索引号。如果里面没有相对元素返回的结果是 - 1;</p>\n<h5 id=\"数组转化成字符串\"><a class=\"markdownIt-Anchor\" href=\"#数组转化成字符串\">#</a> 数组转化成字符串</h5>\n<p><a href=\"https://imgtu.com/i/IGUiu9\"><img src=\"https://z3.ax1x.com/2021/11/08/IGUiu9.png\" alt=\"IGUiu9.png\"></a></p>\n<h4 id=\"字符串对象\"><a class=\"markdownIt-Anchor\" href=\"#字符串对象\">#</a> 字符串对象</h4>\n<p>基本包装类型：就是把简单数据类型 包装称为了 复杂数据类型<br>\n (1) 把简单数据类型包装称为复杂数据类型<br>\n var temp = new String (‘Andy’)<br>\n(2) 把临时变量的值给 str<br>\nstr=temp<br>\n (3) 销毁这个临时变量<br>\n temp = null<br>\n<a href=\"https://imgtu.com/i/IGrOYR\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrOYR.png\" alt=\"IGrOYR.png\"></a></p>\n<h5 id=\"字符串的不可变型\"><a class=\"markdownIt-Anchor\" href=\"#字符串的不可变型\">#</a> 字符串的不可变型</h5>\n<p><a href=\"https://imgtu.com/i/IGU1HI\"><img src=\"https://z3.ax1x.com/2021/11/08/IGU1HI.png\" alt=\"IGU1HI.png\"></a></p>\n<blockquote>\n<pre><code>   var str = '改革吹风吹满地'\n   console.log(str.indexOf('吹',3));\n</code></pre>\n</blockquote>\n<h5 id=\"根据位置返回字符\"><a class=\"markdownIt-Anchor\" href=\"#根据位置返回字符\">#</a> 根据位置返回字符</h5>\n<p><a href=\"https://imgtu.com/i/IGUUgg\"><img src=\"https://z3.ax1x.com/2021/11/08/IGUUgg.png\" alt=\"IGUUgg.png\"></a></p>\n<h5 id=\"字符串操作方法\"><a class=\"markdownIt-Anchor\" href=\"#字符串操作方法\">#</a> 字符串操作方法</h5>\n<p><a href=\"https://imgtu.com/i/IGUavQ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGUavQ.png\" alt=\"IGUavQ.png\"></a></p>\n<blockquote>\n<pre><code>   var str = '改革春风吹满地'\n   console.log(str.substr(2, 2));  //第一个2是索引号的2  第二个2是取几个字符\n</code></pre>\n</blockquote>\n<h5 id=\"替换字符串\"><a class=\"markdownIt-Anchor\" href=\"#替换字符串\">#</a> 替换字符串</h5>\n<blockquote>\n<pre><code>replace('被替换的字符','替换为的字符')\n</code></pre>\n</blockquote>\n<p>如果有相同的两个字符 只会替换前面一个字符</p>\n<h5 id=\"把字符串转化成数组\"><a class=\"markdownIt-Anchor\" href=\"#把字符串转化成数组\">#</a> 把字符串转化成数组</h5>\n<p>split (‘分隔符’) 把字符转换成数组<br>\n join (‘分隔符’) 把数组转换成字符串</p>\n<p>split 中的分隔符取决于原字符串中的分隔符是什么</p>\n<h3 id=\"web-apis\"><a class=\"markdownIt-Anchor\" href=\"#web-apis\">#</a> Web APIs</h3>\n<p>浏览器提供的一套操作浏览器功能和页面元素的 API</p>\n<h4 id=\"dom\"><a class=\"markdownIt-Anchor\" href=\"#dom\">#</a> DOM</h4>\n<p><a href=\"https://imgtu.com/i/IGrvSx\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrvSx.png\" alt=\"IGrvSx.png\"></a></p>\n<h4 id=\"获取页面元素\"><a class=\"markdownIt-Anchor\" href=\"#获取页面元素\">#</a> 获取页面元素</h4>\n<h5 id=\"id获取\"><a class=\"markdownIt-Anchor\" href=\"#id获取\">#</a> ID 获取</h5>\n<p>getElementByld()<br>\n console.dir (); 打印我们返回的元素对象 更好地查看里面的属性和方法</p>\n<h5 id=\"根据标签名来获取\"><a class=\"markdownIt-Anchor\" href=\"#根据标签名来获取\">#</a> 根据标签名来获取</h5>\n<p>element.getElementsByTagName (‘标签名’)<br>\n 1. 获取过来元素对象的集合 以伪数组的形式储存<br>\n 2. 如果页面中只有一个元素 返回的还是伪数组的形式<br>\n 3. 如果页面中没有这个元素 返回的是空的伪数组</p>\n<blockquote>\n<pre><code>   var lis = document.getElementsByTagName('ul')\n   var li = lis[0].getElementsByTagName('li')\n</code></pre>\n</blockquote>\n<h5 id=\"根据类型来获取新增html5属性\"><a class=\"markdownIt-Anchor\" href=\"#根据类型来获取新增html5属性\">#</a> 根据类型来获取 (新增 Html5 属性)</h5>\n<p>document.getElementsByClassName (‘类名’)<br>\n document.querySelector (‘选择器’) 根据选择器返回第一个元素对象<br>\n document.querySelectorAll (‘选择器’) 根据选择器返回所有的集合</p>\n<h5 id=\"获取特殊元素\"><a class=\"markdownIt-Anchor\" href=\"#获取特殊元素\">#</a> 获取特殊元素</h5>\n<p>1. 获取 body 元素<br>\n document.body<br>\n2. 获取 html 元素<br>\n document.documentElement</p>\n<h4 id=\"事件基础\"><a class=\"markdownIt-Anchor\" href=\"#事件基础\">#</a> 事件基础</h4>\n<p>js 让我们有能力创建动态页面，而时间是可以被 js 侦测到的行为<br>\n在网页中每个元素都可以产生某些触发 js 的事件</p>\n<p>事件的组成部分<br>\n 1. 事件源：事件被触发的对象<br>\n 2. 事件类型：如何触发 什么事件 比如 鼠标点击 (onclick) 触发  还是鼠标经过触发<br>\n 3. 事件处理程序：通过函数赋值的方式完成</p>\n<h5 id=\"执行事件的步骤\"><a class=\"markdownIt-Anchor\" href=\"#执行事件的步骤\">#</a> 执行事件的步骤</h5>\n<p>1. 获取事件源<br>\n 2. 绑定事件<br>\n 3. 添加事件处理程序 (采取函数赋值的形式)</p>\n<h4 id=\"操作元素\"><a class=\"markdownIt-Anchor\" href=\"#操作元素\">#</a> 操作元素</h4>\n<h5 id=\"改变元素内容\"><a class=\"markdownIt-Anchor\" href=\"#改变元素内容\">#</a> 改变元素内容</h5>\n<p>element.innerText<br>\nelement.innerHTML<br>\n 这两个属性是可读写的 可以获取元素里面的内容<br>\n<a href=\"https://imgtu.com/i/IGUy5V\"><img src=\"https://z3.ax1x.com/2021/11/08/IGUy5V.png\" alt=\"IGUy5V.png\"></a></p>\n<h5 id=\"改变元素属性\"><a class=\"markdownIt-Anchor\" href=\"#改变元素属性\">#</a> 改变元素属性</h5>\n<h5 id=\"表单元素属性设置\"><a class=\"markdownIt-Anchor\" href=\"#表单元素属性设置\">#</a> 表单元素属性设置</h5>\n<p><a href=\"https://imgtu.com/i/IGURv4\"><img src=\"https://z3.ax1x.com/2021/11/08/IGURv4.png\" alt=\"IGURv4.png\"></a></p>\n<h5 id=\"修改样式属性\"><a class=\"markdownIt-Anchor\" href=\"#修改样式属性\">#</a> 修改样式属性</h5>\n<p>element.style 行内样式操作<br>\n element.className 类名样式操作<br>\n<a href=\"https://imgtu.com/i/IGaMGT\"><img src=\"https://z3.ax1x.com/2021/11/08/IGaMGT.png\" alt=\"IGaMGT.png\"></a></p>\n<p>onfocus 获得焦点事件<br>\n onblur 失去焦点事件</p>\n<h5 id=\"操作元素总结\"><a class=\"markdownIt-Anchor\" href=\"#操作元素总结\">#</a> 操作元素总结</h5>\n<p><a href=\"https://imgtu.com/i/IGaNIx\"><img src=\"https://z3.ax1x.com/2021/11/08/IGaNIx.png\" alt=\"IGaNIx.png\"></a></p>\n<h5 id=\"排他思想\"><a class=\"markdownIt-Anchor\" href=\"#排他思想\">#</a> 排他思想</h5>\n<p>先清除样式，再给当前元素设置样式</p>\n<blockquote>\n<pre><code>   var btn = document.getElementsByTagName('button')\n   for (i = 0; i &lt; btn.length; i++) {\n       btn[i].onclick = function () {\n           for (i = 0; i &lt; btn.length; i++) {\n               btn[i].style.backgroundColor = 'white'\n           }\n           this.style.backgroundColor = 'pink'\n       }\n   }\n</code></pre>\n</blockquote>\n<p>鼠标经过 onmouseover<br>\n 鼠标离开 onmouseout</p>\n<h5 id=\"自定义属性值的操作\"><a class=\"markdownIt-Anchor\" href=\"#自定义属性值的操作\">#</a> 自定义属性值的操作</h5>\n<h6 id=\"获取属性值\"><a class=\"markdownIt-Anchor\" href=\"#获取属性值\">#</a> 获取属性值</h6>\n<p><a href=\"https://imgtu.com/i/IGa0zD\"><img src=\"https://z3.ax1x.com/2021/11/08/IGa0zD.png\" alt=\"IGa0zD.png\"></a></p>\n<h6 id=\"设置属性值\"><a class=\"markdownIt-Anchor\" href=\"#设置属性值\">#</a> 设置属性值</h6>\n<p>element. 属性 = ‘值’<br>\nelement.setAttribute (‘属性’,‘值’)</p>\n<p>setAttribute 主要用于设置自定义属性</p>\n<p>removeAttribute 移除属性</p>\n<h6 id=\"h5自定义属性值\"><a class=\"markdownIt-Anchor\" href=\"#h5自定义属性值\">#</a> H5 自定义属性值</h6>\n<p>H5 新规范：自定义属性都用 data- 开头<br>\n H5 新增的获取自定义属性的方法 <a href=\"http://element.dataset.XXX\">element.dataset.XXX</a><br>\ndataset 是一个集合 里面存放了所有以 data 开头的自定义属性<br>\n如果自定义属性里面有多个 - 链接的单词，我们获取的时候采取驼峰命名法</p>\n<p><a href=\"https://imgtu.com/i/IGrz6K\"><img src=\"https://z3.ax1x.com/2021/11/08/IGrz6K.png\" alt=\"IGrz6K.png\"></a></p>\n<h4 id=\"节点操作\"><a class=\"markdownIt-Anchor\" href=\"#节点操作\">#</a> 节点操作</h4>\n<p>为什么要学节点操作<br>\n<a href=\"https://imgtu.com/i/IGaRFP\"><img src=\"https://z3.ax1x.com/2021/11/08/IGaRFP.png\" alt=\"IGaRFP.png\"></a></p>\n<h5 id=\"节点概述\"><a class=\"markdownIt-Anchor\" href=\"#节点概述\">#</a> 节点概述</h5>\n<p><a href=\"https://imgtu.com/i/IGa4SS\"><img src=\"https://z3.ax1x.com/2021/11/08/IGa4SS.png\" alt=\"IGa4SS.png\"></a></p>\n<h5 id=\"节点层级\"><a class=\"markdownIt-Anchor\" href=\"#节点层级\">#</a> 节点层级</h5>\n<p><a href=\"https://imgtu.com/i/IGaIyQ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGaIyQ.png\" alt=\"IGaIyQ.png\"></a></p>\n<h5 id=\"父节点\"><a class=\"markdownIt-Anchor\" href=\"#父节点\">#</a> 父节点</h5>\n<p><a href=\"https://imgtu.com/i/IGaHwn\"><img src=\"https://z3.ax1x.com/2021/11/08/IGaHwn.png\" alt=\"IGaHwn.png\"></a></p>\n<h5 id=\"子节点\"><a class=\"markdownIt-Anchor\" href=\"#子节点\">#</a> 子节点</h5>\n<p><a href=\"https://imgtu.com/i/IGaLF0\"><img src=\"https://z3.ax1x.com/2021/11/08/IGaLF0.png\" alt=\"IGaLF0.png\"></a><br>\n<a href=\"https://imgtu.com/i/IGaboq\"><img src=\"https://z3.ax1x.com/2021/11/08/IGaboq.png\" alt=\"IGaboq.png\"></a><br>\n<a href=\"https://imgtu.com/i/IGdSOJ\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdSOJ.png\" alt=\"IGdSOJ.png\"></a></p>\n<h5 id=\"兄弟节点\"><a class=\"markdownIt-Anchor\" href=\"#兄弟节点\">#</a> 兄弟节点</h5>\n<p><a href=\"https://imgtu.com/i/IGdCwR\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdCwR.png\" alt=\"IGdCwR.png\"></a><br>\n 解决兄弟节点的兼容性问题:<br>\n<a href=\"https://imgtu.com/i/IGdumd\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdumd.png\" alt=\"IGdumd.png\"></a></p>\n<h5 id=\"创建和删除节点\"><a class=\"markdownIt-Anchor\" href=\"#创建和删除节点\">#</a> 创建和删除节点</h5>\n<h6 id=\"创建节点\"><a class=\"markdownIt-Anchor\" href=\"#创建节点\">#</a> 创建节点</h6>\n<p><a href=\"https://imgtu.com/i/IGsC0e\"><img src=\"https://z3.ax1x.com/2021/11/08/IGsC0e.png\" alt=\"IGsC0e.png\"></a></p>\n<h6 id=\"添加节点\"><a class=\"markdownIt-Anchor\" href=\"#添加节点\">#</a> 添加节点</h6>\n<p><a href=\"https://imgtu.com/i/IGdGp8\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdGp8.png\" alt=\"IGdGp8.png\"></a><br>\nnode.appendChild(child)<br>\n node.insertbefore (child, 指定元素);</p>\n<h6 id=\"删除节点\"><a class=\"markdownIt-Anchor\" href=\"#删除节点\">#</a> 删除节点</h6>\n<p>code.removeChild (节点)<br>\neg:ul.removeChild(ul.children[0])</p>\n<h6 id=\"复制节点克隆节点\"><a class=\"markdownIt-Anchor\" href=\"#复制节点克隆节点\">#</a> 复制节点 (克隆节点)</h6>\n<p>node.cloneNode()<br>\n 如果括号为空，则只复制标签 不复制里面的内容<br>\n括号里面为 true 则里面的内容也跟着赋值</p>\n<h6 id=\"三种动态创建元素区别\"><a class=\"markdownIt-Anchor\" href=\"#三种动态创建元素区别\">#</a> 三种动态创建元素区别</h6>\n<p>document.write () 如果页面加载完毕 再执行这个指令 会导致页面全部重绘<br>\n innerHTML<br>\ndocument.createElement(’’)<br>\n 最后两个大致上没有区别 但是如果需要创造很多个元素 最后一个的效率会大大提高，因为最后一个不是拼接字符串 而是在电脑中重新开辟一个新的空间</p>\n<p><a href=\"https://imgtu.com/i/IGdDhV\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdDhV.png\" alt=\"IGdDhV.png\"></a><br>\n 改进方法:innerHTML 不采用拼接字符串的方式，而是采用数组形式拼接，现在数组中拼接字符串，然后将数组引入到 innerHTML 中</p>\n<h4 id=\"dom重点核心\"><a class=\"markdownIt-Anchor\" href=\"#dom重点核心\">#</a> DOM 重点核心</h4>\n<p>(一) 创建<br>\n 1.document.write<br>\n2.innerHTML<br>\n3.createElement<br>\n (二) 增<br>\n 1.appendChild<br>\n2.innerBefore<br>\n (三) 删<br>\n 1.removeChild<br>\n (四) 改<br>\n 1. 修改元素属性:src,href,title<br>\n2. 修改普通元素内容:innerHTML,innerText<br>\n3. 修改表单元素:value,type,disabled<br>\n4. 修改元素样式:style,className<br>\n (五) 查<br>\n 1.DOM 提供的 API 方法:getElementById,getElementsByTagName  (<strong>古老用法不推荐</strong>)<br>\n 2.H5 提供的新方法:querySelector,querySelectorAll 提倡<br>\n 3. 利用节点获取元素：父 (parentNode), 子 (children), 兄 (previousElementSibing,nextElementSibing) 提倡<br>\n (六) 属性操作<br>\n 1.setAttribute: 设置 dom 的属性值<br>\n 2.getAttribute: 得到 dom 的属性值<br>\n 3.removeAttribute: 移除属性<br>\n (七) 事件操作<br>\n onclick: 鼠标点击左键触发<br>\n onmouseover: 鼠标经过触发<br>\n onmouseout: 鼠标离开触发<br>\n onfocus: 获得鼠标焦点触发<br>\n onblur: 失去鼠标焦点触发<br>\n onmousemove: 鼠标移动触发<br>\n onmouseup: 鼠标弹起触发<br>\n onmousedown: 鼠标按下触发</p>\n<h4 id=\"事件高级导读\"><a class=\"markdownIt-Anchor\" href=\"#事件高级导读\">#</a> 事件高级导读</h4>\n<h5 id=\"注册事件\"><a class=\"markdownIt-Anchor\" href=\"#注册事件\">#</a> 注册事件</h5>\n<p>传统方式和方法监听注册方式<br>\n<a href=\"https://imgtu.com/i/IGd6cF\"><img src=\"https://z3.ax1x.com/2021/11/08/IGd6cF.png\" alt=\"IGd6cF.png\"></a></p>\n<blockquote>\n<pre><code>eventTarget.addEventListener(type,listener[,useCapture])\n</code></pre>\n</blockquote>\n<p><a href=\"https://imgtu.com/i/IGsktA\"><img src=\"https://z3.ax1x.com/2021/11/08/IGsktA.png\" alt=\"IGsktA.png\"></a><br>\n 里面的事件类型是字符串 必定加引号 不带 on<br>\n 同一个元素 同一个事件可以添加多个侦听器 (事件处理程序)</p>\n<p>AttachEvent 事件监听方式 (<strong>不提倡仅供了解</strong>)<br>\n<a href=\"https://imgtu.com/i/IGsVpt\"><img src=\"https://z3.ax1x.com/2021/11/08/IGsVpt.png\" alt=\"IGsVpt.png\"></a></p>\n<p>注册事件兼容性解决方法<br>\n<a href=\"https://imgtu.com/i/IGdW7R\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdW7R.png\" alt=\"IGdW7R.png\"></a></p>\n<h5 id=\"删除事件解绑事件\"><a class=\"markdownIt-Anchor\" href=\"#删除事件解绑事件\">#</a> 删除事件 (解绑事件)</h5>\n<p>1. 传统法式:element.onclick = null<br>\n2. 方法监听事件: eventTarget.removeEventListener (type,listener [,useCapture])<br>\n 删除事件兼容性解决方案:<br>\n<a href=\"https://imgtu.com/i/IGd4tx\"><img src=\"https://z3.ax1x.com/2021/11/08/IGd4tx.png\" alt=\"IGd4tx.png\"></a></p>\n<h5 id=\"dom事件流\"><a class=\"markdownIt-Anchor\" href=\"#dom事件流\">#</a> DOM 事件流</h5>\n<p><a href=\"https://imgtu.com/i/IGsunS\"><img src=\"https://z3.ax1x.com/2021/11/08/IGsunS.png\" alt=\"IGsunS.png\"></a></p>\n<p>注意事项<br>\n<a href=\"https://imgtu.com/i/IGsGpq\"><img src=\"https://z3.ax1x.com/2021/11/08/IGsGpq.png\" alt=\"IGsGpq.png\"></a><br>\n 捕获阶段<br>\n<a href=\"https://imgtu.com/i/IGs3hn\"><img src=\"https://z3.ax1x.com/2021/11/08/IGs3hn.png\" alt=\"IGs3hn.png\"></a><br>\n 冒泡阶段<br>\n<a href=\"https://imgtu.com/i/IGs1ts\"><img src=\"https://z3.ax1x.com/2021/11/08/IGs1ts.png\" alt=\"IGs1ts.png\"></a></p>\n<h4 id=\"事件对象\"><a class=\"markdownIt-Anchor\" href=\"#事件对象\">#</a> 事件对象</h4>\n<p><a href=\"https://imgtu.com/i/IGdqnH\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdqnH.png\" alt=\"IGdqnH.png\"></a></p>\n<h5 id=\"事件对象的常见属性和方法\"><a class=\"markdownIt-Anchor\" href=\"#事件对象的常见属性和方法\">#</a> 事件对象的常见属性和方法</h5>\n<p><a href=\"https://imgtu.com/i/IGdLBd\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdLBd.png\" alt=\"IGdLBd.png\"></a><br>\ne.target 返回的是触发事件的对象 而 this 返回的是绑定事件的对象，currentTarget 和 this 一样返回的是绑定事件的对象 ie678 不认识 currentTarget<br>\ne.type: 返回事件类型 例如 click,mouseover</p>\n<p>组织默认事件 让链接不跳转 或者让提交按钮不提交 e.preventDefault ();<br>\n<a href=\"https://imgtu.com/i/IGdx4P\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdx4P.png\" alt=\"IGdx4P.png\"></a></p>\n<p>组织事件冒泡 e.stopPropagation ()<br>\n 兼容性解决方法<br>\n<a href=\"https://imgtu.com/i/IGdvNt\"><img src=\"https://z3.ax1x.com/2021/11/08/IGdvNt.png\" alt=\"IGdvNt.png\"></a></p>\n<h5 id=\"事件委托\"><a class=\"markdownIt-Anchor\" href=\"#事件委托\">#</a> 事件委托</h5>\n<p>原理：给父节点添加侦听器，利用事件冒泡影响每一个子节点</p>\n<h5 id=\"常用的鼠标事件\"><a class=\"markdownIt-Anchor\" href=\"#常用的鼠标事件\">#</a> 常用的鼠标事件</h5>\n<p><a href=\"https://imgtu.com/i/IGw9gS\"><img src=\"https://z3.ax1x.com/2021/11/08/IGw9gS.png\" alt=\"IGw9gS.png\"></a><br>\n 禁止鼠标右键菜单:contextmenu 主要控制应该在何时显示上下文菜单，主要用于程序员取消默认的上下文菜单<br>\n禁止鼠标选中:selectstart</p>\n<blockquote>\n<pre><code>   document.addEventListener('contextmenu', function (e) {\n       e.preventDefault();\n   })\n   document.addEventListener('selectstart', function (e) {\n       e.preventDefault();\n   })\n</code></pre>\n</blockquote>\n<h5 id=\"鼠标事件对象\"><a class=\"markdownIt-Anchor\" href=\"#鼠标事件对象\">#</a> 鼠标事件对象</h5>\n<p>Mouseevent 鼠标事件对象<br>\n keyboard 键盘事件对象<br>\n<a href=\"https://imgtu.com/i/IGwCjg\"><img src=\"https://z3.ax1x.com/2021/11/08/IGwCjg.png\" alt=\"IGwCjg.png\"></a><br>\nclient 以可视区为主 跟屏幕滚动没有关系<br>\n page 相对于文档页面的 X 和 Y 坐标<br>\n screen 鼠标相当于电脑屏幕的 X 和 Y 坐标 (当浏览器缩小或者放大时会变化)<br>\n mousemove 鼠标移动事件</p>\n<h5 id=\"键盘事件对象\"><a class=\"markdownIt-Anchor\" href=\"#键盘事件对象\">#</a> 键盘事件对象</h5>\n<p><a href=\"https://imgtu.com/i/IGwkHs\"><img src=\"https://z3.ax1x.com/2021/11/08/IGwkHs.png\" alt=\"IGwkHs.png\"></a><br>\n 三个事件的执行顺序是 keydown keypress keyup</p>\n<p>KeyCode 返回键盘按键的 ASCII 的值<br>\n keyup 和 keydown 事件不区分字母大小写 a 和 A 得到的就是 65<br>\nkeypress 区分字母大小写</p>\n<h3 id=\"bom浏览器对象模型\"><a class=\"markdownIt-Anchor\" href=\"#bom浏览器对象模型\">#</a> BOM 浏览器对象模型</h3>\n<h4 id=\"bom概述\"><a class=\"markdownIt-Anchor\" href=\"#bom概述\">#</a> BOM 概述</h4>\n<p>BOM: 浏览器对象模型<br>\n<a href=\"https://imgtu.com/i/IJFREt\"><img src=\"https://z3.ax1x.com/2021/11/08/IJFREt.png\" alt=\"IJFREt.png\"></a><br>\nBOM 的构成<br>\n<a href=\"https://imgtu.com/i/IJFf4f\"><img src=\"https://z3.ax1x.com/2021/11/08/IJFf4f.png\" alt=\"IJFf4f.png\"></a></p>\n<h4 id=\"浏览器顶级对象window\"><a class=\"markdownIt-Anchor\" href=\"#浏览器顶级对象window\">#</a> 浏览器顶级对象 window</h4>\n<p><a href=\"https://imgtu.com/i/IJF4C8\"><img src=\"https://z3.ax1x.com/2021/11/08/IJF4C8.png\" alt=\"IJF4C8.png\"></a></p>\n<h5 id=\"窗口加载事件\"><a class=\"markdownIt-Anchor\" href=\"#窗口加载事件\">#</a> 窗口加载事件</h5>\n<p>window.onload 窗口加载事件，当文档内容完全加载完成后会触发该事件 (包括图像 css 脚本等等)<br>\n 注意:<br>\n1. 有了 window.onload 我们就可以将 js 写在任何位置 onload 是等页面文档加载完成后 最后加载的东西<br>\n 2.window,onload 传统注册事件只能写一次，如果有多个，会以最后一个 window.onload 为准<br>\n 3. 如果使用 AddEventListener 则没有限制<br>\n document.addEventListener (‘DOMContentLoaded’,function (){})<br>\n 仅当 DOM 加载完成就开始触发，不包括样式表，图片，flash 等等<br>\n后一个加载更快，如果是图片较多的网站等 会因为图片刷新过快 如果使用第一个方式 有可能无法加载出 js 文件 而使用后一个方式 则在 DOM 加载完成后 就加载 js</p>\n<h5 id=\"调整窗口大小事件\"><a class=\"markdownIt-Anchor\" href=\"#调整窗口大小事件\">#</a> 调整窗口大小事件</h5>\n<p><a href=\"https://imgtu.com/i/IGwEEn\"><img src=\"https://z3.ax1x.com/2021/11/08/IGwEEn.png\" alt=\"IGwEEn.png\"></a></p>\n<h4 id=\"定时器\"><a class=\"markdownIt-Anchor\" href=\"#定时器\">#</a> 定时器</h4>\n<h5 id=\"settimeout定时器\"><a class=\"markdownIt-Anchor\" href=\"#settimeout定时器\">#</a> setTimeout () 定时器</h5>\n<p>window.setTimeout (调用函数，[延迟的毫秒数]);<br>\n 在定时器到期后执行函数<br>\n 1.window 在调用的时候可以省略<br>\n 2. 时间单位是毫秒，可以省略 如果省略默认为 0<br>\n3. 页面中可能有很多的定时器 我们经常给定时器起一个标识符</p>\n<p>callback 回调函数<br>\n<a href=\"https://imgtu.com/i/IJFovQ\"><img src=\"https://z3.ax1x.com/2021/11/08/IJFovQ.png\" alt=\"IJFovQ.png\"></a></p>\n<h6 id=\"停止settimeout定时器\"><a class=\"markdownIt-Anchor\" href=\"#停止settimeout定时器\">#</a> 停止 setTimeout () 定时器</h6>\n<p>window.clearaTimeout (定时器名字)</p>\n<h5 id=\"setinterval定时器\"><a class=\"markdownIt-Anchor\" href=\"#setinterval定时器\">#</a> setInterval () 定时器</h5>\n<p><a href=\"https://imgtu.com/i/IJFLEq\"><img src=\"https://z3.ax1x.com/2021/11/08/IJFLEq.png\" alt=\"IJFLEq.png\"></a></p>\n<p>区别:setTimeout 只调用一次回调函数<br>\n setInterval 会一直调用函数</p>\n<h4 id=\"this指向问题\"><a class=\"markdownIt-Anchor\" href=\"#this指向问题\">#</a> this 指向问题</h4>\n<p>1. 全局作用域或者普通函数中 this 指向全局对象 window (定时器里面的 this 指向 window)<br>\n 2. 方法调用中谁调用 this 指向谁<br>\n 3. 构造函数中 this 可以指向构造函数<br>\n<a href=\"https://imgtu.com/i/oSEMu9\"><img src=\"https://z3.ax1x.com/2021/11/22/oSEMu9.png\" alt=\"oSEMu9.png\"></a><br>\n<a href=\"https://imgtu.com/i/oSEQBR\"><img src=\"https://z3.ax1x.com/2021/11/22/oSEQBR.png\" alt=\"oSEQBR.png\"></a></p>\n<h4 id=\"js的执行队列\"><a class=\"markdownIt-Anchor\" href=\"#js的执行队列\">#</a> js 的执行队列</h4>\n<p>js 是单线程的 同一个时间只能做一件事<br>\n为了解决这个问题，利用多核 CPU 的计算能力，HTML5 允许 js 脚本创建多个线程，于是 js 中出现了同步和异步<br>\n<a href=\"https://imgtu.com/i/IGwugU\"><img src=\"https://z3.ax1x.com/2021/11/08/IGwugU.png\" alt=\"IGwugU.png\"></a></p>\n<h5 id=\"js执行机制\"><a class=\"markdownIt-Anchor\" href=\"#js执行机制\">#</a> js 执行机制</h5>\n<p><a href=\"https://imgtu.com/i/IGw1b9\"><img src=\"https://z3.ax1x.com/2021/11/08/IGw1b9.png\" alt=\"IGw1b9.png\"></a><br>\n<a href=\"https://imgtu.com/i/IGwQu4\"><img src=\"https://z3.ax1x.com/2021/11/08/IGwQu4.png\" alt=\"IGwQu4.png\"></a><br>\n<a href=\"https://imgtu.com/i/IJkczF\"><img src=\"https://z3.ax1x.com/2021/11/08/IJkczF.png\" alt=\"IJkczF.png\"></a><br>\n<a href=\"https://imgtu.com/i/IJFz2F\"><img src=\"https://z3.ax1x.com/2021/11/08/IJFz2F.png\" alt=\"IJFz2F.png\"></a><br>\n 事件循环：主线程不断的城府获得任务 执行任务 再获取任务 执行任务</p>\n<h4 id=\"location对象\"><a class=\"markdownIt-Anchor\" href=\"#location对象\">#</a> location 对象</h4>\n<p><a href=\"https://imgtu.com/i/IJAmF0\"><img src=\"https://z3.ax1x.com/2021/11/08/IJAmF0.png\" alt=\"IJAmF0.png\"></a><br>\n<a href=\"https://imgtu.com/i/IJAnYV\"><img src=\"https://z3.ax1x.com/2021/11/08/IJAnYV.png\" alt=\"IJAnYV.png\"></a></p>\n<h5 id=\"location对象方法\"><a class=\"markdownIt-Anchor\" href=\"#location对象方法\">#</a> location 对象方法</h5>\n<p><a href=\"https://imgtu.com/i/IGwJ4x\"><img src=\"https://z3.ax1x.com/2021/11/08/IGwJ4x.png\" alt=\"IGwJ4x.png\"></a><br>\nassign 能够记录历史 可以实现后退功能</p>\n<h4 id=\"navigator对象\"><a class=\"markdownIt-Anchor\" href=\"#navigator对象\">#</a> navigator 对象</h4>\n<p>包含浏览器的信息 有很多属性 我们最常用的属性是 userAgent 该属性可以返回由客户机发送服务器的 user-agent 头部的值</p>\n<p><a href=\"https://imgtu.com/i/IJAuWT\"><img src=\"https://z3.ax1x.com/2021/11/08/IJAuWT.png\" alt=\"IJAuWT.png\"></a></p>\n<h4 id=\"history对象\"><a class=\"markdownIt-Anchor\" href=\"#history对象\">#</a> history 对象</h4>\n<p><a href=\"https://imgtu.com/i/IJAQlF\"><img src=\"https://z3.ax1x.com/2021/11/08/IJAQlF.png\" alt=\"IJAQlF.png\"></a></p>\n<blockquote>\n<pre><code>btn.addEventListener('click',function(){\nhistory.forward();  \n})\nback() 和 go() 同理\n其中go(-1) 表示后退一页 go(-1)表示后退两页\n</code></pre>\n</blockquote>\n<h3 id=\"pc端网页特效\"><a class=\"markdownIt-Anchor\" href=\"#pc端网页特效\">#</a> PC 端网页特效</h3>\n<h4 id=\"元素偏移量offset系列\"><a class=\"markdownIt-Anchor\" href=\"#元素偏移量offset系列\">#</a> 元素偏移量 offset 系列</h4>\n<p>动态获取元素位置和大小</p>\n<ul>\n<li>获取元素距离带有定位父元素的位置</li>\n<li>获得元素自身的大小 (包含 padding 和 border)</li>\n<li>返回的数值不带单位</li>\n</ul>\n<p><a href=\"https://imgtu.com/i/oih8C6\"><img src=\"https://z3.ax1x.com/2021/11/24/oih8C6.png\" alt=\"oih8C6.png\"></a><br>\noffsetParent  返回的是带有定位的父元素 (没有则返回 body)<br>\n parentNode 返回的是最近一级的父元素 不管父元素有没有定位</p>\n<h5 id=\"offset和style的区别\"><a class=\"markdownIt-Anchor\" href=\"#offset和style的区别\">#</a> offset 和 style 的区别</h5>\n<ul>\n<li>offsetWidth 与 style.width<br>\n<a href=\"https://imgtu.com/i/oiTCtA\"><img src=\"https://z3.ax1x.com/2021/11/24/oiTCtA.png\" alt=\"oiTCtA.png\"></a></li>\n</ul>\n<h4 id=\"元素可视区client系列\"><a class=\"markdownIt-Anchor\" href=\"#元素可视区client系列\">#</a> 元素可视区 client 系列</h4>\n<p>使用 client 系列的相关属性获取元素可视区的相关信息<br>\n通过 client 系列的相关属性可以动态得到该元素的边框大小，元素大小等<br>\n<a href=\"https://imgtu.com/i/oib09s\"><img src=\"https://z3.ax1x.com/2021/11/24/oib09s.png\" alt=\"oib09s.png\"></a></p>\n<h4 id=\"淘宝源码分析\"><a class=\"markdownIt-Anchor\" href=\"#淘宝源码分析\">#</a> 淘宝源码分析</h4>\n<h5 id=\"立即执行函数\"><a class=\"markdownIt-Anchor\" href=\"#立即执行函数\">#</a> 立即执行函数</h5>\n<p>不需要调用 立即执行</p>\n<blockquote>\n<pre><code>(function XXX() { })()  第二个小括号可以看成调用函数 也可以传递参数\n(function XXX(){}()) 第二个小括号可以看成调用函数 也可以传递参数\n</code></pre>\n</blockquote>\n<ul>\n<li>XXX 为函数名 可以省略</li>\n<li><strong>多个立即执行函数之间必须使用分号隔开</strong></li>\n<li>好处：独立创建了一个作用域 里面所有的变量都是局部变量 避免了命名冲突的问题</li>\n</ul>\n<h4 id=\"元素滚动scroll系列\"><a class=\"markdownIt-Anchor\" href=\"#元素滚动scroll系列\">#</a> 元素滚动 scroll 系列</h4>\n<p>得到元素的大小 滚动距离 与页面中的滚动条有关<br>\n<a href=\"https://imgtu.com/i/oAwKnP\"><img src=\"https://z3.ax1x.com/2021/11/25/oAwKnP.png\" alt=\"oAwKnP.png\"></a><br>\n<strong> 不包含边框 包含 padding 值</strong><br>\n对于超出父元素的汉字 会按照所有汉字叠加的高度计算 (真正的内容实际大小)<br>\n 与 client 不同的是 client 并不会计算超出的大小 而只是原有父元素的大小<br>\n<a href=\"https://imgtu.com/i/oA0u8J\"><img src=\"https://z3.ax1x.com/2021/11/25/oA0u8J.png\" alt=\"oA0u8J.png\"></a></p>\n<h5 id=\"scroll事件\"><a class=\"markdownIt-Anchor\" href=\"#scroll事件\">#</a> scroll 事件</h5>\n<p>当滚动条发生变化时会触发的事件</p>\n<blockquote>\n<pre><code>XXX.document.addEventListener('scroll',function(){})\n</code></pre>\n</blockquote>\n<h4 id=\"动画函数封装\"><a class=\"markdownIt-Anchor\" href=\"#动画函数封装\">#</a> 动画函数封装</h4>\n<p>通过定时器 setInterval () 不断移动盒子的位置<br>\n 1. 获取当前位置<br>\n 2. 给当前位置加一个移动距离<br>\n 3. 利用定时器不断重复这个操作<br>\n 4. 结束定时器<br>\n<strong> 5. 元素需要添加定位才能使用 element.style.left</strong></p>\n<h5 id=\"动画函数简单封装\"><a class=\"markdownIt-Anchor\" href=\"#动画函数简单封装\">#</a> 动画函数简单封装</h5>\n<blockquote>\n<pre><code>function animate(obj, target) {\n    clearInterval(obj.timer)\n    obj.timer = setInterval(function () {\n        if (obj.offsetLeft &gt;= target) {\n            clearInterval(obj.timer)\n        } else\n            obj.style.left = obj.offsetLeft + 2 + 'px';\n    }, 30)\n}\n</code></pre>\n</blockquote>\n<h5 id=\"缓动动画\"><a class=\"markdownIt-Anchor\" href=\"#缓动动画\">#</a> 缓动动画</h5>\n<ol>\n<li>让盒子每次移动的距离慢慢变小 速度就会慢慢慢下来</li>\n<li>核心算法：(目标值 - 现在的位置)/10</li>\n<li>盒子等于目标位置就停止计时器</li>\n</ol>\n",
            "tags": [
                "Javascript"
            ]
        }
    ]
}